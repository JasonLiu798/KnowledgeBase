
[快速排序算法原理及实现（单轴快速排序、三向切分快速排序、双轴快速排序）](http://www.cnblogs.com/nullzx/p/5880191.html)

# 单轴快速排序
快速排序的基本思想就是从一个数组中任意挑选一个元素（通常来说会选择最左边的元素）作为中轴元素，将剩下的元素以中轴元素作为比较的标准，将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，然后以当前中轴元素的位置为界，将左半部分子数组和右半部分子数组看成两个新的数组，重复上述操作，直到子数组的元素个数小于等于1（因为一个元素的数组必定是有序的）。

# 快速排序中元素切分的方式
快速排序中最重要的就是步骤就是将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，我们暂时把这个步骤定义为切分。而剩下的步骤就是进行递归而已，递归的边界条件为数组的元素个数小于等于1。以首元素作为中轴，看看常见的切分方式。

2.1 从两端扫描交换的方式

基本思想，使用两个变量i和j，i指向首元素的元素下一个元素（最左边的首元素为中轴元素），j指向最后一个元素，我们从前往后找，直到找到一个比中轴元素大的，然后从后往前找，直到找到一个比中轴元素小的，然后交换这两个元素，直到这两个变量交错（i > j）（注意不是相遇 i == j，因为相遇的元素还未和中轴元素比较）。最后对左半数组和右半数组重复上述操作。

	public static void QuickSort1(int[] A, int L, int R){
		if(L < R){//递归的边界条件，当 L == R时数组的元素个数为1个
			int pivot = A[L];//最左边的元素作为中轴，L表示left, R表示right
			int i = L+1, j = R;
			//当i == j时，i和j同时指向的元素还没有与中轴元素判断，
			//小于等于中轴元素，i++,大于中轴元素j--,
			//当循环结束时，一定有i = j+1, 且i指向的元素大于中轴，j指向的元素小于等于中轴
			while(i <= j){
				while(i <= j && A[i] <= pivot){
					i++;
				}
				while(i <= j && A[j] > pivot){
					j--;
				}
				//当 i > j 时整个切分过程就应该停止了，不能进行交换操作
				//这个可以改成 i < j， 这里 i 永远不会等于j， 因为有上述两个循环的作用
				if(i <= j){
					Swap(A, i, j);
					i++;
					j--;
				}
			}
			//当循环结束时，j指向的元素是最后一个（从左边算起）小于等于中轴的元素
			Swap(A, L, j);//将中轴元素和j所指的元素互换
			QuickSort1(A, L, j-1);//递归左半部分
			QuickSort1(A, j+1, R);//递归右半部分
		}
	}
 

2.2 两端扫描，一端挖坑，另一端填补

基本思想，使用两个变量i和j，i指向最左边的元素，j指向最右边的元素，我们将首元素作为中轴，将首元素复制到变量pivot中，这时我们可以将首元素i所在的位置看成一个坑，我们从j的位置从右向左扫描，找一个小于等于中轴的元素A[j]，来填补A[i]这个坑，填补完成后，拿去填坑的元素所在的位置j又可以看做一个坑，这时我们在以i的位置从前往后找一个大于中轴的元素来填补A[j]这个新的坑，如此往复，直到i和j相遇（i == j，此时i和j指向同一个坑）。最后我们将中轴元素放到这个坑中。最后对左半数组和右半数组重复上述操作。

	public static void QuickSort2(int[] A, int L, int R){
		if(L < R){
			//最左边的元素作为中轴复制到pivot，这时最左边的元素可以看做一个坑
			int pivot = A[L];
			//注意这里 i = L,而不是 i = L+1, 因为i代表坑的位置,当前坑的位置位于最左边
			int i = L, j = R;
			while(i < j){
				//下面面两个循环的位置不能颠倒，因为第一次坑的位置在最左边
				while(i < j && A[j] > pivot){
					j--;
				}
				//填A[i]这个坑,填完后A[j]是个坑
				//注意不能是A[i++] = A[j],当因i==j时跳出上面的循环时
				//坑为i和j共同指向的位置,执行A[i++] = A[j],会导致i比j大1，
				//但此时i并不能表示坑的位置
				A[i] = A[j];
				
				while(i < j && A[i] <= pivot){
					i++;
				}
				//填A[j]这个坑，填完后A[i]是个坑，
				//同理不能是A[j--] = A[i]				
				A[j] = A[i];
			}
			//循环结束后i和j相等，都指向坑的位置，将中轴填入到这个位置
			A[i] = pivot;
			
			QuickSort2(A, L, i-1);//递归左边的数组
			QuickSort2(A, i+1, R);//递归右边的数组
		}
	}
 

2.3 单端扫描方式

j从左向右扫描，A[1,i]表示小于等于pivot的部分，A[i+1,j-1]表示大于pivot的部分，A[j, R]表示未知元素
















