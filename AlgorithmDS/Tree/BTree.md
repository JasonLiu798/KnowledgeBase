# B树相关
---
# doc 
[B树和B+树的总结](https://www.cnblogs.com/George1994/p/7008732.html)
[B树](http://blog.csdn.net/u012658346/article/details/51253017)
[B树、B-树、B+树、B*树的定义和区分](https://www.cnblogs.com/wjoyxt/p/5501706.html)

---
# B-Tree

一个 m 阶的B树满足以下条件：
* 每个结点至多拥有m棵子树；
* 根结点至少拥有两颗子树（存在子树的情况下）；
* 除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；
* 所有的叶结点都在同一层上；
* 有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；
* 关键字数量需要满足ceil(m/2)-1 <= n <= m-1；

## 创建
B-TREE_CREATE(T)
{
    x=allocate_node();
    leaf[x]=true;
    n[x]=0;
    DISK_WRITE(x);
    root[T]=x;
}

## 查找
B-TREE-SEARCH(x,k)
{
    i=1;
    while(i<=n[x] && k>key(x,i)){
        ++i;
    }
    if(i<=n[x] && k==key(x,i)){
        return (x,i);
    }
    if(leaf[x])
        return NULL;
    else{
        DISK_READ(ci[x]);
        return B-TREE-SEARCH(ci[x],k);
    }
}

## 插入
* 如果该结点的关键字个数没有到达m-1个，那么直接插入即可；
* 如果该结点的关键字个数已经到达了m-1个，那么根据B树的性质显然无法满足，需要将其进行分裂。分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。

### 分裂
B-TREE-SPLIT-CHILD(x,i,y)
{
    z=allocate_node();
    leaf[z]=leaf[y];
    n[z]=t-1;
    for(j=1;j<=t-1;++j){ //y中后半部分key拷贝到z中
        z[j]=y[t+j];
    }
    if(!leaf[y]){
        for(j=1;j<=t;++j){ //y中后半部分子树拷贝到z中
        c(z,j)=c(y,j+t);
    }
    n[y]=t-1;
    for(j=n[x]+1;j>i;--j){ //x中i之后是子树的指针后移1个
        c(x,j+1)=c(x,j);
    }
    c(x,i+1)=z;
    for(j=n[x];j>=i;--j){ //x中的key后移1位
        x[j+1]=x[j];
    }
    x[i]=y[t]; //y中中间节点提升到x中
    n[x]+=1;
    DISK_WRITE(x);
    DISK_WRITE(y);
    DISK_WRITE(z);


## 删除
通过搜索找到相应的值，存在则进行删除，需要考虑删除以后的情况，
* 如果该结点拥有关键字数量仍然满足B树性质，则不做任何处理；
* 如果该结点在删除关键字以后不满足B树的性质（关键字没有到达ceil(m/2)-1的数量），则需要向兄弟结点借关键字，这有分为兄弟结点的关键字数量是否足够的情况。
	- 如果兄弟结点的关键字足够借给该结点，则过程为将父亲结点的关键字下移，兄弟结点的关键字上移；
	- 如果兄弟结点的关键字在借出去以后也无法满足情况，即之前兄弟结点的关键字的数量为ceil(m/2)-1，借的一方的关键字数量为ceil(m/2)-2的情况，那么我们可以将该结点合并到兄弟结点中，合并之后的子结点数量少了一个，则需要将父亲结点的关键字下放，如果父亲结点不满足性质，则向上回溯；
* 其余情况参照BST中的删除。


----
# B+树
由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。

## m阶B+树
* 根结点只有一个，分支数量范围为[2，m]
* 分支结点，每个结点包含分支数范围为[ceil(m/2), m]
* 分支结点的关键字数量等于其子分支的数量减一，关键字的数量范围为[ceil(m/2)-1, m-1]，关键字顺序递增
* 所有叶子结点都在同一层

其操作和B树的操作是类似的，不过需要注意的是，在增加值的时候，如果存在满员的情况，将选择结点中的值作为新的索引，还有在删除值的时候，索引中的关键字并不会删除，也不会存在父亲结点的关键字下沉的情况，因为那只是索引。

## B+树的分裂
当一个结点满时，分配一个新的结点，并将原结点中1/2的数据
复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父
结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

## 插入删除
[图解B+树的插入和删除](http://blog.csdn.net/scythe666/article/details/40345783)
[B+树（插入，非惰性删除）](http://blog.csdn.net/zju_fish1996/article/details/57413734)


## B树和B+树的区别
以一个m阶树为例
* 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
* 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上
* 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。
* 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。


---
# B*树
B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；


---
# B-树
是一种多路搜索树（并不是二叉的）：
* 1.定义任意非叶子结点最多只有M个儿子；且M>2；
* 2.根结点的儿子数为[2, M]；
* 3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
* 4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
* 5.非叶子结点的关键字个数=指向儿子的指针个数-1；
* 6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
* 7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的
子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
* 8.所有叶子结点位于同一层；

## B-树的特性：
* 1.关键字集合分布在整颗树中；
* 2.任何一个关键字出现且只出现在一个结点中；
* 3.搜索有可能在非叶子结点结束；
* 4.其搜索性能等价于在关键字全集内做一次二分查找；
* 5.自动层次控制；
* 由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少
利用率，其最底搜索性能为：O(log_2(N))
























