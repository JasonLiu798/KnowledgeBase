#动态规划算法
---
[常见的动态规划问题分析与求解](http://www.cnblogs.com/wuyuegb2312/p/3281264.html)

#概念
　　动态规划（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。
　　动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许 多 子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同 一个 子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。
　　关于动态规划最经典的问题当属背包问题。

---
#算法步骤：
1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多 次。 动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题 时，只是 在表格中简单地查看一下结果，从而获得较高的效率。



---
#常用算法
##最大子串和问题（Maximum Subarray）
[wiki](https://en.wikipedia.org/wiki/Maximum_subarray_problem)
[cnblog 含On3 On2,常数级优化](http://www.cnblogs.com/en-heng/p/3970231.html)
[正确性](http://blog.csdn.net/joylnwang/article/details/6859677):
要说明Kadane算法的正确性，需要两个结论。
首先，对于array[1...n]，如果array[i...j]就是满足和最大的子串，那么对于任何k(i<=k<=j)，我们有array[i...k]的和大于0。
因为如果存在k使得array[i...k]的和小于0，那么我们就有array[k+1...j]的和大于array[i...j]，这与我们假设的array[i...j]就是array中和最大子串矛盾。

我们可以将数组从左到右分割为若干子串，使得除了最后一个子串之外，其余子串的各元素之和小于0，且对于所有子串array[i...j]和任意 k（i <= k < j ）
有array[i...k]的和大于0。此时我们要说明的是，满足条件的和最大子串，只能是上述某个子串的前缀，而不可能跨越多个子串。
假设array[p...q]，是array的和最大子串，且array[p...q]，
跨越了array[i...j]，array[j+1...k]
```
p                                       q
        i           j j+1          k
            m                n
```
根据我们的分组方式
    存在i <= m < j 使得array[i...m]的和是array[i...j]中的最大值，
    存在j+1<=n < k 使得array[j+1...n]的和是array[j+1...k]的最大值
    由于array[m+1...j] 使得array[i...j]的和小于0
    此时我们可以比较array[i...m]和array[j+1...n]，如果array[i...m]的和大于array[j+1...n]，则array[i...m]>array[p...q]，否array[j+1...n]>array[p...q]，
    无论谁大，我们都可以找到比array[p...q]和更大的子串，这与我们的假设矛盾
    所以满足条件的array[p...q]不可能跨越两个子串。对于跨越更多子串的情况，由于各子串的和均为负值，所以同样可以证明存在和更大的非跨越子串的存在。对于单元素和最大的特例，该结论也适用。













