#基础概念
##整型 机内码
1、正数5的表示法
假设有一个 int 类型的数，值为5，那么，我们知道它在计算机中表示为：
00000000 00000000 00000000 00000101
5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。

2、负数-5的表示法
[关于2的补码](http://www.ruanyifeng.com/blog/2009/08/twos_complement.html)
现在想知道，-5在计算机中如何表示？在计算机中，负数以原码的补码形式表达。
源码+补码=11.....111
1111...1111+1=000000

概念：
1、原码：一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码。
比如 00000000 00000000 00000000 00000101 是 5的 原码。
     10000000 00000000 00000000 00000101 是 -5的 原码。
 
   备注：
   比如byte类型,用2^8来表示无符号整数的话,是0 - 255了；如果有符号， 最高位表示符号,0为正,1为负,那么,正常的理解就是 -127 至 +127 了.这就是原码了,值得一提的是,原码的弱点,有2个0,即+0和-0（10000000和00000000）；还有就是,进行异号相加或同号相减时,比较笨蛋,先要判断2个数的绝对值大小,然后进行加减操作,最后运算结果的符号还要与大的符号相同；于是,反码产生了。

2、反码：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反[每一位取反(除符号位)]。
取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）
比如：正数00000000 00000000 00000000 00000101  的反码还是 00000000 00000000 00000000 00000101
      负数10000000 00000000 00000000 00000101  的反码则是 11111111 11111111 11111111 11111010。

反码是相互的，所以也可称：10000000 00000000 00000000 00000101 和 11111111 11111111 11111111 11111010互为反码。

备注：还是有+0和-0,没过多久，反码就成为了过滤产物,也就是,后来补码出现了。

3、补码：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.
比如：10000000 00000000 00000000 00000101 的补码是：11111111 11111111 11111111 11111010。
那么，补码为：
11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011

备注：1、从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。
      2、补码却规定0没有正负之分

所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。


三、再举一例
我们来看整数-1在计算机中如何表示。假设这也是一个int类型，那么：
1、先取-1的原码：10000000 00000000 00000000 00000001
2、得反码：     11111111 11111111 11111111 11111110（除符号位按位取反）
3、得补码：     11111111 11111111 11111111 11111111

可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF

四、主要知识点：

正数的反码和补码都与原码相同。
负数的反码为对该数的原码除符号位外各位取反。
负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1

源码：优点在于换算简单 缺点在于两个零 加减法需要独立运算
反码：有点在于表示清晰 缺点在于两个零 加减法同样需要独立运算
补码：优点在于一个零 范围大  减法可以转为加法 缺点在于理解困难

下面是书上原文：

原码表示法规定：用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示，数值部分用二进制形式表示。
反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。
补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.
正零和负零的补码相同，[+0]补=[-0]补=0000 0000B

五、特殊情况-128
1000 0000,那么,它的原码是什么呢?从补码求原码的方法跟原码求补码是一样的。先保留符号位其它求反:  1111 1111, 再加1，11000 0000, 超过了8位了。对,用8位数的原码在这里已经无法表示了。

那么,回到原码处, 它的原码也是 1000 0000(超出的自动丢失),1000 0000 在原码表示什么呢? -0, 但补码却规定0没有正负之分。
转换一下思路,看看计算机里,是怎么运算的:
对于负数,先取绝对值,然后求反,加一
-128 -> 128 -> 1000 0000 -> 0111 1111 -> 1000 0000
现在明确了吧
所以, 8位有符号的整数取值范围的补码表示
1000 0000 到 0000 0000, 再到 0111 1111
即 -128 到 0, 再到 127
最终 -128 ~ +127

永远记住：程序里的加减法对 二进制是永远有效的。但是并不一定适合于真实世界。

byte m = -128;
byte q = 1;
byte p = (byte)(m - q); //这一步其实编译器会报错，其实是发现越界了，我们强行转化为byte就可以看出结果。
System.out.println( p); p的结果为：127


-----
#float double 机内码
符号位|0~255(exp)|



----
#book
[书籍推荐](http://www.nowamagic.net/librarys/veda/books/)













