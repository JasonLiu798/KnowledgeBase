#Distributed System Concepts And Design
---
#book
[分布式系统概念与设计](https://book.douban.com/subject/2698938/)

#C1 分布式系统的特征
##定义
分布式系统是一个硬件或软件组件分布在不同网络计算机上，彼此之间通过消息传递进行通信和协调的系统
##特性
分布性
对等性
并发性
缺乏全局时钟
故障总会发生

##挑战
###1 异构性
网络、硬件、操作系统、编程语言、不同开发者完成的软件
中间件，提供编程抽象，屏蔽了异构性

###2 开放性
新的资源共享服务能否被增加和供多种客户程序使用的程度

###3 安全性
消息内容；身份；DDOS

###4 可伸缩性
控制物理资源开销
控制性能损失
防止软件资源用尽，ipv4
避免性能瓶颈

###5 故障处理
检测故障
掩盖故障
	消息不能到达时重传；
	双写，磁盘损坏，另一个仍然可读
容错
故障恢复
冗余

###6 并发性

###7 透明性
访问，操作方式，调用方式
位置
并发
复制，无需知道副本相关信息 
故障
移动
性能
伸缩

###8 服务质量

##分布式环境常见问题
通信异常
网络分区
三态
	成功、失败
	超时：网络端口，发送的消息丢失；处理完后，响应的消息丢失；因此无法判断是否处理成功
节点故障

----
#C2 系统模型
##1 物理模型
分布式系统底层硬件元素的表示
###基线物理模型
通过消息传递进行通信和协调动作的系统
###早期
规模：小
异构性：有限
开放性：
服务质量：
###互联网规模
可扩展的节点集合 通过互联网相连
规模：大
异构性：平台、语言、中间件 都较大
开放性：一系列标准
服务质量：一系列服务
###当代分布式
静态 分立 自治
规模：超大
异构性：维度增加
开放性：已有标准不能包含复杂系统
服务质量：已有的服务不能包含复杂系统
###超大规模
系统的系统

##2 体系结构模型
用独立指定的组件 以及 这些组件之间的关系 来表示的 结构
###体系结构元素
* 通信实体
进程，线程，硬件节点
对象
组件，依赖显式化

* 通信范型
请求-应答
RPC RMI
以上发送和接收的双向关系，多数情况，发送接收者同时存在
间接通信：
空间解耦，发送者不需要知道发送给谁；时间解耦，发送 接收不需要同时存在
1 组通信：一对多
2 发布-订阅
3 消息队列
4 元组空间：进程可以把任意结构化数据项放到一个持久元组空间，其他进程可以指定感兴趣的模式，从而在元组空间读或删除元组
5 分布式共享内存：DistributedSharedMemory

* 角色和责任
客户-服务器
对等体系结构，P2P

* 如何映射到物理设施，放置
Q：性能，可靠性，安全性
从进程角度看，机器负载，通信质量
服务映射到多个服务器
缓存
移动代码：applet
移动代理

###体系结构模式
* 分层
每层一个软件抽象
* 层次化体系结构
与分层互补
组织给定层功能的技术
* ajax
* 瘦客户
* 代理
* 业务代理
* 反射

###2.3.3 中间件解决方案
类别
最早：RPC 组通信ISIS
分布式对象;
分布式组件;
发布-订阅系统;
消息队列;
web服务;
对等;

限制
分布式程序的正确行为在很多层面依赖检查、错误校正机制、安全手段
底层中间件行为与一个给定应用或应用集的需求和相关环境上下文有关

##2.4基础模型
目的：
显式表示有关我们正在建模的系统的假设
给定这些假设，就可行性给出结论 算法，逻辑证明
###2.4.1 交互模型
影响进程交互的两个重要因素：
* 通信性能经常是一个限制特性
* 不可能维护一个全局时间概念

通信信道性能
延迟；带宽；抖动

计算机时钟和时序事件
时钟漂移率

####交互模型的两个变体
同步分布式系统
* 进程执行每一步的时间有一个上限和下限
* 通过通道传递的每个消息在一个已知的时间范围内收到
* 每个进程有个本地时钟，它与实际时间的偏移率在一个已知的范围内
给出偏移率简单，但保证偏移率很难

异步分布式系统
对下列因素没有限制：
* 进程执行速度
* 消息传递延迟
* 时钟飘移率

####事件排序
Pepperland协定
逻辑时钟

###2.4.2 故障模型
* 遗漏故障
进程遗漏故障，进程崩溃
对此检测：进程不能应答，依赖超时（崩溃/速度慢/消息还没到达）

* 通信遗漏故障
从进程p的外发缓冲区send到q的接收缓冲区，之间丢失
发送遗漏故障：发送进程-外发缓冲区之间
接收遗漏故障：接收缓冲区和接收进程之间
通道遗漏故障：以上之间的

* 随机故障
可能出现的最坏的故障

* 时序故障
适用于同步分布式系统

* 故障屏蔽
隐藏或将故障转换为一个更能接收的故障类型来屏蔽故障

* 一对一通信的可靠性
有效性：外发缓冲区的任何信息最终能传递到接收缓冲区
完整性：接收到的消息与发送的消息一致，没有消息被传送两次

###2.4.3 安全模型

保护对象
保护进程和交互
解除安全威胁
* 密码学和共享秘密
* 密码学
* 认证
* 安全通道

其他
* DDOS
* 移动代码


---
#C3 网络和网际互联
#3.1简介
性能
延迟
数据传输率
传输时间=延迟+length/数据传输率
#3.2 网络类型
PAN 个域网
LAN 局域网
WAN 广域网
MAN 城域网
WLAN 无线局域网
WMAN 无线城域网
互联网络

#3.3网络原理
##1 数据包的传输
长度有限的数据包：
* 需要分配缓存空间
* 避免长消息引起的通信空闲，而出现过度延迟

##数据流

##交换模式
广播
电路交换
包交换
帧中继

##协议
* 必须交换的消息的顺序的规约
* 消息中数据格式的规约

##3.3.5路由
距离向量算法
链路状态算法

##3.3.6拥塞控制
为了避免经过拥塞节点被丢弃，最好将数据包保存在拥塞之前的节点，直到拥塞减少
会增加延迟，但不会降低整个网络吞吐量

##3.3.7网际互联
实现集成需要：
* 统一的互联寻址方案
* 定义互连网络中的数据包格式并给出相应处理规则协议
* 互连组件

#3.4 互联网协议
##1 IP寻址
##2 IP协议
##3 IP路由

##4 IPv6

##5 移动IP

#3.5实力研究：以太网、Wifi、蓝牙
##1 以太网
数据包冲突
效率

##2 802.11无线LAN
工作站隐藏：由于无线电屏障，检测不到其他正在传输的主机
信号衰减：只能检测到有限距离内的冲突
冲突屏蔽

CSMA/CA 具有冲突避免的载波侦听多路复用

##3 802.15.1 蓝牙

---
#C4 进程间通信
#4.1 简介

#4.2 互联网协议的API
##1 进程间通信的特征
同步和异步
消息的目的地 


##2 套接字

##3 udp数据报通信
##4 tcp流通信
消息大小
丢失的消息
流控制
消息重复和排序
消息目的地

需要注意的问题
* 数据项匹配
* 阻塞
* 线程

###故障模型
网络不稳定 或严重拥塞 导致收不到确认，超时后，tcp会声明连接中断，如果还试图读写操作，则会受到通知，造成：
* 使用连接的进程不能区分网络故障还是连接另一端的进程故障
* 通信进程不能区分最近发送的消息是否已经被收到

#4.3 外部数据表示和编码
大端、小端
##二进制协议

##自描述协议
xml

#4.4 组播通信

#4.5 网络虚拟化：覆盖网络
##2 skype
super node

#4.6 实例研究 MPI

---
#C5 远程调用
#5.1 简介
#5.2 请求应答协议
基于通信原语：doOperation getRequest sendReply

##消息标示符
* requestId，递增整数序列
* 发送进程的标示符

##故障模型
如果基于UDP，则会遇到
* 遗漏故障
* 没有保障消息按照发送顺序进行传输

##超时
等待，或告知调用方

##丢弃重复的请求消息

##丢失应答信息
幂等

##历史

##交互协议的类型
请求协议 R
请求-应答协议 RR
请求-应答-确认协议 RRA

##请求-应答协议 TCP流的使用

#5.3 远程过程调用
##1 设计问题
接口编程
接口实现分离

###RPC调用语义
doOperation
重发请求消息
过滤重复请求
重传结果
或许调用语义

至少一次
至多一次

###透明性
故障定位
延迟
引用调用

##2 rpc实现

#5.4 远程方法调用
##1 设计问题
##2 rmi实现
##3 分布式无用单元收集

#5.5 java rmi

---
#C6 间接通信
#6.1 简介
计算机科学中，所有问题都可以通过某个层次上的间接方式解决
没有通过消除某种层次上的间接方式解决不了的性能问题

			| 时间耦合 | 时间解耦
空间耦合	|		   | 
空间解耦	|		   |

#6.2 组通信
消息首先发送到组中，然后该消息被传送到组中的所有成员。
发送者不清楚接受者的身份
##1 编程模型
核心：组、组成员
进程组和对象组
其他主要区别：封闭和开放组
重叠和非重叠组
##2 实现问题
协定(agreement)，消息被传递到一个进程，那么消息被传递到本组所有进程

有序组播：
FIFO
因果序
全序：如果在一个进程中，一个消息在另一个之前被传递，那么相同的顺序将在所有进程上维持

#6.3 发布-订阅系统（基于事件的分布式系统）
主要特征：
异构性
异步性
	位置解耦、事件解耦

##编程模型
发布者
	publish
	advertise 声明将要发布的事件特性

发布-订阅系统
	notify

订阅者
	subscribe
	unsubscribe

###模式
基于渠道：
基于主题：
基于内容：基于主题的一般化，基于内容过滤，组合查询
基于类型：根据事件类型

##实现
泛洪：向所有节点发送事件通知，不必要的网络流量
过滤：基于过滤的路由，维护邻居列表、订阅列表、路由表
广告：
汇聚：分布式散列表
闲聊协议


#6.4 消息队列
##编程模型
接收方式：
阻塞接收
非阻塞接收（轮询）
通知

持久性

#6.5 共享内存
分布式共享内存

元组空间通信





------------
#C7 OS支持
#7.4 进程和线程

##4 实现
用户级线程
缺点：
* 不能利用多核
* 页失配会阻塞整个进程和进程内所有线程
* 不同进程中的线程不能按统一优先级方案调度
优点：
* 某些线程操作 开销小
* 消除调度模块在内核外实现，那么，可被定制或改变以满足特定应用的需求
* 支持比内核默认更多的用户级线程

虚拟处理器
调度器激活 shceduler activation SA，内核到进程的调用
upcall

#7.5 通信和调用

rpc开销
包初始化
线程调度和上下文切换
确认等待


----
#C8 分布式对象和组件 -

----
#C9 web服务

##9.2.1 SOAP

#9.3 WSDL

#9.4 web服务使用的目录服务

---
#C10 对等系统  P2P

##10.5.3 从结构化对等方法到非结构化对等方法
有效的搜索策略
* 扩展环搜索
* 随机漫步
* 闲聊

---
#C11 安全性
#11.1 简介
#11.2 安全技术概述
##11.2.2 密码学的应用
私密性和完整性
	认证

##11.2.4 访问控制
op,principal,resource
保护域
resource,rights

权能

访问控制列表
domain,operations

#11.3 密码算法
##11.3.2 公钥算法

##11.3.3 混合密码协议

#11.4 数字签名

---
#C12 分布式文件系统


---
#C13 名字服务
DNS
递归
非递归

----
#C14 时间和全局状态


## 14.2 时钟、事件和进程状态
时钟偏移：两个时钟读数的瞬间不同
时钟漂移：温度、不同的振荡器 等，随着时间误差累积；漂移率

##14.3 同步物理时钟
外部同步

内部同步
###14.3.1 同步系统中的同步
T_trans 两个进程间传输所花费时间
max最大传输时间，min最小传输时间
传输时间的不确定性 u=(max-min)
设为t+min，偏移最多为u
设为t+max，偏移可能为u
设为t+(min+max)/2，偏移最多为u/2
同步N个时钟，最优范围 u(1-1/N)

###14.3.2 cristian方法
S连到UTC，与外部同步
p-----m_r---->S
 <----m_t----
只有客户和服务器之间往返时间与所要求的精确性相比足够短，该方法才能达到同步

T_round=p到S再返回的时间
设S在 m_t 中放置t
往返时间在t时间点之前和之后平分，那么p应该设置时钟为t+T_round/2，除非m_r m_t 在不同网络
如果min值已知或可保守估计，那么可用如下方法判断结果精确性
S能在m_t中放置时间的最早点是在p发出m_r之后的min
消息到达S的时钟的时间范围[t+min,t+T_round-min]，范围宽度是T_round-2min，精确度是 ±(T_round/2-min)

依赖接近min的时间，繁忙的网络中 不太可能

###14.3.3 berkeley算法
master轮询slave，获取slave时钟值，计算平均值
准确性依赖 最大往返时间

###14.3.4 NTP 网络时间协议

##14.4 逻辑时间和逻辑时钟
因果序，或潜在因果序

逻辑时钟
LC1：在进程p_i发出每个事件前，L_i加1
L_i: = L_i+1
LC2：
a)当进程p_i发送消息m时，在m中附加值t=L_i
b)在接收(m,t)时，进程p_j计算L_j:=max(L_j,t)，然后在给receive(m)事件打时间戳应用LC1
e->e'=>L(e)<L(e') 相反不成立

全序逻辑时钟

向量时钟

##14.5 全局状态
###14.5.1 全局状态和一致割集
全局历史
	H=h_0 U h_1 ... h_N-1
割集
	C= h^{C1}_{1} U h^{C2}_{2} ... h^{CN}_{N}
边界

割集C是一致的，条件是 包含每个事件，包含该事件发生之前的所有事件


### 14.5.3 Chandy和lamport的快照算法


## 14.6 分布式调试
### 14.6.1 搜集状态

### 14.6.2 观察一致的全局状态









---
# C15 协调和协定
## 15.1 简介
不可靠故障检测：
unsuspected，最近没有收到有故障的证据，但可能之后就立马出现故障
suspected，有迹象可能已经出现故障，但可能出现网络，正常运行在另一边；或者运行的比预期要慢

可靠的故障检测器：精确检测进程故障的检测器
Unsuspected，同上
Failed，确定已经崩溃

每隔T秒发送一次，
最大消息传输时间D
T+D秒没有收到

可靠检测要求系统是同步的

## 15.2 分布式互斥

### 中央服务器算法
请求、授权

### 基于环的算法
单向环

### 组播和逻辑时钟算法


### maekawa投票算法
不比要求所有对等进程都同意
任意两进程使用的子集有重叠

容易死锁，修改后的协议，进程按发生顺序对待应答请求排队

##15.3 选举
* 安全性 参与的进程p_i有elected_i=null或elected_i=P，其中P是运行结束时有最大标示符的非崩溃进程
* 活性 所有进程p_i都参与并且最终或者置elected_i≠ null 或者进程p_i崩溃

### 基于环的选举


### 霸道算法
T=2T_trans+T_process

## 15.4 组通信中的协调与协定


FIFO排序
全排序
因果排序

## 15.5 共识和相关问题
### 15.5.1 系统模型和问题定义
一组通过消息传递进行通信的进程p_i(i=1,2,...,N)
N个进程，至多有f个有错

#### 共识问题的定义
每个进程p_i最初位于未决(undecided)状态，提议集合D中的一个值v_i(i=1,2,...,N)
每个进程设置一个决定变量d_i(i=1,2,...,N)，进入决定状态

* 终止性：每个正确进程最终设置它的决定变量
* 协定性：所有正确进程的决定值都相同，即如果p_i和p_j是正确的并且已进入决定状态，那么d_i=d_j(i,j=1,2,...,N)
* 完整性：如果正确的进程都提议同一个值，那么处于*决定状态* 的任何正确进程已选择了该值。

系统是异步的，可能不会终止

#### 拜占庭将军问题
和共识问题的区别：
拜占庭有独立的进程提供一个值，其他进程决定是否采用；
共识问题是每个进程提议一个值，

* 终止性：每个正确进程最终设置它的决定变量
* 协定性：所有正确进程的决定值都相同：如果p_i和p_j是正确的并且已进入决定状态，那么d_i=d_j(i,j=1,2,...,N)
* 完整性：如果司令是正确的，那么所有进程都采取司令提议的值

#### 交互一致性
共识问题的变种，每个进程提议一个值。
正确的进程最终就一个值向量达成一致，向量中的分量与一个进程值对应
这个向量为决定向量

* 终止性：每个正确进程最终设置它的决定变量
* 协定性：所有正确进程的决定向量都相同
* 完整性：如果进程p_i是正确的，那么所有正确的进程都把v_i作为它们决定变量中的第i个分量

#### 共识问题与其他问题的关联


### 15.5.2 同步系统中的共识问题

N个进程，最多有f个进程崩溃
进行f+1个回合

### 15.5.3 同步系统中的拜占庭将军问题

### 15.5.4 异步系统的不可能性





----
#C16 事务和并发控制
#16.1 简介
##16.1.1 简单的同步机制
synchronized
执行分散到不同时间中

##16.1.2 故障模型
持久写操作故障

服务器偶尔崩溃，内存数据丢失，被重置

消息传递可能有任意长度延迟，消息丢失、重复、损坏

#16.2 事务
请求是原子的：
* 不受其他并发客户操作干扰
* 所有操作或者全部完成，或者服务器故障时不产生影响

ACID
原子性
一致性
隔离性
持久性

为了支持故障原子性和持久性，对象必须是可恢复的


##16.2.1 并发控制
更新丢失
	并发读，写被覆盖

不一致检索
	并发读写

串行等价性
	如果每个事务知道单独执行的正确效果，那么可以推断出这些事务按某种次序一次执行一个事务的结果也正确。
	如果并发事务交错执行效果 等同于 按某种次序一次执行的结果，那么这种交错执行是一种串行等价的交错执行。

冲突操作
两个操作的执行效果和他们的执行次序相关

并发控制方法：
锁、乐观并发控制、时间戳排序

##16.2.2 事务放弃时的修复
脏数据读取
事务可恢复性
连锁放弃
	读取了未提交的
过早写入
	读的数据不同，并发写不同数据
事务的严格执行
临时版本

#16.3 嵌套事务
顶层事务、子事务
子事务可以单独提交
父事务 可根据子事务 提交结果 选择不同处理方式

#16.4 锁
锁的粒度
读写锁

实现
锁管理器

##16.4.1 死锁
预防死锁
	一开始就锁住需要访问的所有对象， 不必要的资源访问限制
	按预定顺序加锁；但会 过早加锁，减少并发度
更新锁
死锁检测，环路检测
超时
	可能没有锁，但事务超时

##16.4.2 增加并发度
双版本锁
	写操作可在临时版本上写操作，但写事务可能提交时等待或拒绝
层次锁

#16.5 乐观并发控制
锁的缺点：
	维护带来的额外开销
	死锁
	为避免连锁放弃，必须事务结束才能释放锁，并发度低


乐观策略
工作阶段
验证阶段
更新阶段

后向验证
	比较 被验证事务的 读集 和 已提交事务的 写集
	验证失败：放弃当前事务

向前验证
	Tv的 写集合 要与 所有重叠活动事务的 读集合 进行比较
	冲突解决：
		推迟验证
		放弃冲突活动事务，提交已验证的
		放弃被验证的事务

#16.6 时间戳排序
唯一的时间戳

---
#C17 分布式事务
#17.3 原子提交协议
##17.3.1 2pc

##17.3.2 嵌套事务的2pc
层次化2pc

平面2pc

#17.4 分布式事务 并发控制
##17.4.1 加锁
很容易死锁

##17.4.2 时间戳并发控制
协调者开始分配一个唯一时间戳

##17.4.3 乐观并发控制

#17.5 分布式死锁
集中式检测死锁
假死锁
	检测过程中，某些事务放弃了等待
边追逐

事务优先级

#17.6 事务恢复


-----------------------------------------------------
#C18 复制
## 18.1 简介
增强性能
提高可用性
	网络分区
	断链操作
容错

要求：
复制透明性
一致性

## 18.2 系统模型和组通信的作用
### 18.2.1 系统模型

### 18.2.2 组通信的作用

#### 视图传递
* 完整性
* 顺序
* 非平凡性

#### 视图同步的组通信
协定
完整性
有效性

##18.3 容错服务

### 线性化能力和顺序一致性
可线性化的：
* 操作的交错执行序列符合对象的（单个）正确副本所遵循的规约
* 操作的交错执行次序和实际运行中的次序实时一致

顺序一致性：
* 操作的交错执行序列符合对象的（单个）正确副本所遵循的规约
* 操作的交错执行次序和在每个客户程序中执行的次序一致

### 18.3.1 被动（主备份）复制
任何时候都有一个主副本管理器和一个或多个次备份副本管理器

master：主副本管理器
slave：备份副本管理器

#### 事件顺序
请求：FE发送请求到 master，保括一个唯一标示符
协调：master按请求次序原子执行每一个请求
执行：master执行请求并存储应答
协定：如果请求是更新操作，那么master像每个slave发送更新后的状态、应答和唯一标示符，slave返回一个确认
响应：master将响应FE，FE应答客户

仍然具备线性化能力的成立条件：
* master被唯一的slave代替
* 当接管Master时，剩余slave在哪些操作已被执行上达成一致

缺点：
开销较大

变种：读slave

### 18.3.2 主动复制

#### 事件顺序
请求：FE请求加上唯一标示符 并将其组播到副本管理器组
协调：组通信系统以同样的次序（全序）将请求传递到每个正确的副本管理器
执行：每个副本管理器执行请求，由于他们是状态机，并且请求以相同的全排序方式传递，因此正确的副本管理器以相同的方式处理请求。请求应答包括客户的唯一请求标示符
协定：鉴于组播传递语义，无需此阶段
响应：每个副本管理器 把应答发送给FE，FE收到应答数量取决于故障模型的假设和组播算法

## 18.4 高可用服务的实例研究：闲聊体系结构、bayou  和 coda
### 18.4.1 闲聊体系结构

* 请求：FE发送请求到一个副本管理器，使用的如果出现故障或不可达，将和另一个通信。当正常的副本管理器负担过重时，FE也将尝试使用其他副本管理器。
* 对更新操作的响应：如果请求是一个更新，副本管理器收到更新就立即回答
* 协调：收到请求的副本管理器并不处理操作，知道它能根据所要求的次序约束处理请求为止。
* 执行：副本管理器执行请求
* 对查询操作的响应：如果请求是一个查询操作，副本管理器将在此给出回答
* 协定：副本管理器通过交换闲聊消息进行相互更新，这些闲聊消息包含了大多数最近收到的更新。

前端的版本时间戳

副本管理器状态













