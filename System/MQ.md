#MessageQueue
---
#theory
[mq comparison](http://blog.csdn.net/joeyon1985/article/details/38487395)

[performance](http://bravenewgeek.com/dissecting-message-queues/)

---
#JMS
[Spring JMS 消息处理 1-2-3](http://www.ibm.com/developerworks/cn/java/wa-spring4/)


---
#Q&A
##消息发送一致性
context:
process->send message
send message->process
Reason:应用系统故障，消息系统故障
Solution:
    XA，分布式事务
    最终一致，暂存消息，业务成功再发送

##消息中间件与使用者强依赖
使用者消息入库，业务操作与入库作为本地事务，但消息中间件需要访问库

消息模型对消息接收的影响


## 消息模型对消息接收的影响
集群间 Topic模型
集群内 Queue模型

持久订阅：消费者存在则接收数据，不存在则保留等到下次启动后发送
非持久订阅：消费者存在则接收数据，不存在则不接收，消息不单独保留

## 保证消息可靠性的做法
Sender send to MQ



###MQ save message
消息表投递表，
分开
单独表（消费者共用一个字段）
    无法按消费者索引，只能按消息检索
    长度有限，消费者数量有限
    处理较快的集群，与慢集群的矛盾

单机raid，要考虑单机安全性
多机数据同步，复制有延迟
应用双写，应对存储自身复制有延迟，应用会变复杂

###MQ send to Receiver 投递的可靠性
投递，确认线程分离，避免确认慢的customer阻塞线程池
一个应用，多个订阅者，订阅多份同样


## Receiver角度，消息重复产生和应对
原因：
    MQ down
    MQ 负载高，响应慢
    success应答返回时Network down

应对：
要求Receiver消息处理为幂等操作

## 保证顺序的消息队列

## Push和Pull对比
Push    |  Pull
服务端|消费端
维护每次传输状态|   不需要
实时| 根据pull间隔
依据订阅者消费能力做流控|消费端根据自身能力决定pull


---
#软负载中心
地址聚合
生命周期感知

##上下线感知
可能问题：
1.软负载中心本身负载过大，导致接收心跳超时，可用服务器被误判
2.服务到软负载中心链路问题
解决方案：
1.通过历史连接和心跳数据判断，交给第三方验证（但有可能第三方和服务方链路出现问题，但Provicer和customer之间正常，解决办法让customer确认）

##数据分发的特点和设计
分发与订阅的区别
1.MQ保证每条消息不丢失
软负载中心只保证最新数据送到相关订阅者，不保证每次变化都被最终订阅者感知
2.消息中间件，同一集群不同机器分享所有消息
软负载中心，维护大家都需要的服务数据

提升分发性能需要注意的问题
数据压缩
全量与增量的选择

##针对服务化的特性支持
软负载数据分组
    根据环境区分
    分优先级的隔离
提供自动感知以外的上下线开关
    优雅的停止服务
    保持应用场景，用于排错

##从单机到集群
数据管理问题
连接管理问题
1.数据统一管理
管理连接的机器可以是无状态的
根据职责分离
2.数据对等管理方案
每个节点有整个集群的数据，节点对等，各节点之间数据同步


---







