
# 重构 笔记

# C1 第一个案例
什么时候重构：添加新特性时，现有的代码结构无法很方便的达成目的

## 1.2 重构第一步
核对是否有测试，没有则添加
	添加则涉及到对原本业务的梳理
自我检测能力

## 1.3 分解并重组statement
提炼函数 extractMethod
	找到局部变量 和参数
修改变量名：好的名字 更容易让其他人理解
移动函数到对应上下文，原来调用点改为委托调用
去除临时变量，改为查询函数，

## 1.4 多态取代switch
最好不要在另一个对象基础属性上运用switch，不得不用，最好在对象自己的数据上用

一部影片可以在生命周期内修改分类，一个对象不能修改所属的类
State模式，抽出 price类，可以使movie动态修改价格

重构的节奏：测试->小修改->测试->小修改...

---
# C2 重构原则
## 2.1 什么是重构
（名词）对软件内部结构的一种调整，目的是不改变软件可观察行为的前提下，提高理解性，降低修改成本
（动词）使用一系列重构收发，在不改变软件可观察行为的前提下，调整其结构

两顶帽子：
添加新功能，重构
不要同时进行，添加新功能时，需要添加测试
重构时，不要添加功能，只改进结构，必要时修改测试

## 2.2 为何重构
不是银弹
### 改进软件设计
维持当初的设计
消除重复代码，确定的事物和行为只在代码中表述一次
### 更容易理解
看的更远
### 帮助找到bug
更深入的理解代码
### 提高编程速度
良好的设计是快速开发的根本

## 2.3 何时重构
不必特别抽出时间去做
三次法则
添加功能时
	无法快速添加
修补错误时
	不能清晰到一眼看出bug
code review
	
难以修改的原因：
难以阅读
逻辑重复
添加新行为要改旧代码
复杂逻辑

## 2.4 怎么对经理说
间接层的价值
* 允许逻辑共享
* 分开解释意图和实现
* 隔离变化
* 封装条件逻辑，多态消息

## 2.5 重构的难题
### 数据库
增加分隔层，分离库模型和对象模型，但是会增加系统复杂度；因此可以留到对象不稳定时再添加
### 修改接口
已经发布的接口，调用新接口
### 难以通过重构完成的设计改动
### 何时不该重构
改动太大，成本高到还不如重写一份
现有代码不能正常运作
时间不够

## 2.6 重构与设计
软件可塑性更强
一种观点：重构可以取代预先设计
但没有重构，就必须花很大时间和精力到预先设计上

需要预先设计，不必找到一个正确的完美的，而需要一个合理的解决方案

灵活性需要代价：
建造一个灵活的解决方案，成本难以估算，如果在可能变化点都建立灵活性，复杂度和维护难度都大大提高

## 2.7 重构与性能
先写出可调的软件，再调整获得足够速度
时间预算法，最严格
持续关注法，一旦性能改善分散到个个角落，每次改善都只是对程序行为的一个狭隘视角出发
2-8法则
利用上述90%的统计数据

短期内的重构可能让系统变慢（如加入了中间层），但是后续的优化会更容易

## 2.8 重构起源何处
有效的度量系统，找到性能瓶颈

---
# C3 代码坏味道






















































































