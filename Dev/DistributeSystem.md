#distribute system developemnt
---
#theory
[notes-on-distributed-systems](http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/)
[分布式系统的事务处理](http://tech.dezai.cn/Detail.Aspx?AI=90001)
[《七周七并发模型》作者 Paul Butcher：用并发计算实现最大效率](http://segmentfault.com/a/1190000002801864)
HSF框架

---
#CAS
1)要想让数据有高可用性,就得写多份数据。
2)写多份的问题会导致数据一致性的问题。
3)数据一致性的问题又会引发性能问题
##一致性模型
1)Weak 弱一致性:当你写入一个新值后,读操作在数据副本上可能读出来,也可能读不出来。比如:某些cache系统,网络游戏其它玩家的数据和你没什么关系,VOIP这样的系统,或是百度搜索引擎(呵呵)。
2)Eventually 最终一致性:当你写入一个新值后,有可能读不出来,但在某个时间窗口之后保证最终能读出来。比如:DNS,电子邮件、Amazon S3,Google搜索引擎这样的系统。
3)Strong 强一致性:新的数据一旦写入,在任意副本任意时刻都能读到新值。比如:文件系统,RDBMS,Azure Table都是强一致性的。

Weak和Eventually一般来说是异步冗余的,而Strong一般来说是同步冗余的,异步的通常意味着更好的性能,但也意味着更复杂的状态控制。同步意味着简单,但也意味着性能下降

##实现
###Master-Slave
首先是Master-Slave结构,对于这种加构,Slave一般是Master的备份。在这样的系统中,一般是如下设计的:
1)读写请求都由Master负责。
2)写请求写到Master上后,由Master同步到Slave上。

###Master-Master
每个Master都提供read-write服务。这个模型是Master-Slave的加强版,数据间同步一般是通过Master间的异步完成,所以是最终一致性。
如果多个Master对同一个数据进行修改的时候,这个模型的恶梦就出现了——对数据间的冲突合并,这并不是一件容易的事情。看看Dynamo的Vector Clock的设计(记录数据的版本号和修改者)就知道这个事并不那么简单,而且Dynamo对数据冲突这个事是交给用户自己搞的。就像我们的SVN源码冲突一样,对于同一行代码的冲突,只能交给开发者自己来处理。

###Two/Three Phase Commit
引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)
第一阶段:
协调者会问所有的参与者节点,是否可以执行提交操作。
各个参与者开始事务执行的准备工作:如:为资源上锁,预留资源,写undo/redo log……
参与者响应协调者,如果事务的准备工作成功,则回应“可以提交”,否则回应“拒绝提交”。
第二阶段:
如果所有的参与者都回应“可以提交”,那么,协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交,并释放所有资源,然后回应“完成”,协调者收集各节点的“完成”回应后结束这个Global Transaction。
如果有一个参与者回应“拒绝提交”,那么,协调者向所有的参与者发送“回滚操作”,并释放所有资源,然后回应“回滚完成”,协调者收集各节点的“回滚”回应后,取消这个Global Transaction。

问题：
A)其中一个是同步阻塞操作,这个事情必然会非常大地影响性能
B)另一个主要的问题是在TimeOut上

1)如果第一阶段中,参与者没有收到询问请求,或是参与者的回应没有到达协调者。那么,需要协调者做超时处理,一旦超时,可以当作失败,也可以重试。
2)如果第二阶段中,正式提交发出后,如果有的参与者没有收到,或是参与者提交/回滚后的确认信息没有返回,一旦参与者的回应超时,要么重试,要么把那个参与者标记为问题节点剔除整个集群,这样可以保证服务节点都是数据一致性的。
3)糟糕的情况是,第二阶段中,如果参与者收不到协调者的commit/fallback指令,参与者将处于“状态未知”阶段,参与者完全不知道要怎么办,比如:如果所有的参与者完成第一阶段的回复后(可能全部yes,可能全部no,可能部分yes部分no),如果协调者在这个时候挂掉了。那么所有的节点完全不知道怎么办(问别的参与者都不行)。为了一致性,要么死等协调者,要么重发第一阶段的yes/no命令。
所以引入三段提交
二段提交的第一个段break成了两段:询问,然后再锁资源。最后真正提交。
在询问的时候并不锁定资源,除非所有人都同意了,才开始锁资源。

##Two Generals Problem/拜占庭将军问题
[拜占庭将军问题](https://zh.wikipedia.org/zh/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98)
###两将军问题(消息的确认)
有两支军队,它们分别有一位将军领导,现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近,分占一座山头。一道山谷把两座山分隔开来,并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是,这个山谷已经被那座城市的保卫者占领,并且存在一种可能,那就是任何被派出的信使通过山谷是会被捕。 请注意,虽然两位将军已经就攻击那座城市达成共识,但在他们各自占领山头阵地之前,并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此,他们必须互相沟通,以确定一个时间来攻击,并同意就在那时攻击。如果只有一个将军进行攻击,那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考:
1)第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而,一旦信使被派遣,他是否通过了山谷,第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫,因为如果第二位将军不能在同一时刻发动攻击,那座城市的驻军就会击退他的军队的进攻,导致他的军队被摧毁。
2)知道了这一点,第二位将军就需要发送一个确认回条:“我收到您的邮件,并会在9点的攻击。”但是,如果带着确认消息的信使被抓怎么办?所以第二位将军会犹豫自己的确认消息是否能到达。
3)于是,似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而,如果这位信使被抓怎么办呢?
4)这样一来,是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。

试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。
使用一个能够承受通信信道不可靠性的方案,并不试图去消除这个不可靠性,但要将不可靠性削减到一个可以接受的程度。

---
#Paxos算法
Paxos的目的是让整个集群的节点对某个值的变更达成一致

Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案,是否通过这个提案取决于这个集群中是否有超过半数的节点同意(所以Paxos算法需要集群中的节点是单数)。

假设这个有三个节点:A,B,C):

第一阶段:Prepare阶段
Sequence Number(你可以认为是一个提案号,这个数不断递增,而且是唯一的,也就是说A和B不可能有相同的提案号


第二阶段:Accept阶段
如果提案者A收到了超过半数的节点返回的Yes,然后他就会向所有的节点发布Accept Request(同样,需要带上提案号n),如果没有超过半数的话,那就返回失败。

##Fast Paxos


---
#NWR模型
N代表N个备份,W代表要写入至少W份才认为成功,R表示至少读取R个备份。配置的时候要求W+R > N。 因为W+R > N, 所以 R > N-W 这个是什么意思呢?就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。



---
#服务QoS

#服务治理


---
#cluster
[norbert](http://data.linkedin.com/opensource/norbert)


---
#分布式session
按ID hash到同一台机器，一致性hash解决机器增减、故障情况


----
#存储系统
##直连式存储DAS
##网络存储NAS SAN
NAS并发访问同一个文件，会导致读写速度大幅下降
##分布式文件系统


---
#trace 分布式跟踪
[Dapper，大规模分布式系统的跟踪系统](http://bigbully.github.io/Dapper-translation/)

##watchman
[微博平台的链路追踪及服务质量保障系统——Watchman系统](http://www.infoq.com/cn/articles/weibo-watchman)
[微博平台的链路追踪及服务质量保障系统——Watchman系统](http://blog.csdn.net/alex19881006/article/details/24382393)
###设计目标
* 低侵入性（non-invasivenss）：作为非业务组件，应当尽可能少侵入或者不侵入其他业务系统，保持对使用方的透明性，可以大大减少开发人员的负担和接入门槛。
* 灵活的应用策略（application-policy）：可以决定所收集数据的范围和粒度。
* 时效性（time-efficient）：从数据的收集和产生，到数据计算/处理，再到展现或反馈控制，都要求尽可能得快速。
* 决策支持（decision-support）：这些数据数据是否能在决策支持层面发挥作用，特别是从DevOps的角度。

###实现
#### 埋点
watchman-runtime组件利用字节码增强的方式在载入期织入增强逻辑（load-time weaving），为了跨进程/线程传递请求上下文，对于跨线程watchman-enhance组件通过javaagent的方式在应用启动并载入class时修改了JDK自身的几种线程池（ThreadPool或几类Executor）实现，在客户代码提交（execute或submit）时对传入的runnable/callable对象包上具有追踪能力的实现（proxy-pattern），并且从父线程上去继承或初始化请求上下文（request-context）；

普通Java调用的处理方式（埋点/追踪）则是通过AspectJ的静态织入



阀门策略，





[twitter zipkin](https://twitter.github.io/zipkin/)
[hydra](https://github.com/odenny/hydra)

[鹰眼下的淘宝 - 阿里技术沙龙](http://wenku.baidu.com/link?url=xsorjRmT7vuIedegixzLF5uC4q5KooXqC-ePnPRKm1eunUDfnjU3vDlPkZqWgHbSCUJUIUivM8FnVCsMZcde0xTxCUu9t0DVFhDKLJdBQye###)


[dubbo开发 ](http://dubbo.io/Developer+Guide-zh.htm#DeveloperGuide-zh-%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E6%89%A9%E5%B1%95)





