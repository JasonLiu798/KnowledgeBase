#Tree
---
#BinaryTree
二叉查找树(二叉排序树)的详细实现
http://blog.csdn.net/touch_2011/article/details/6831924


普通的二叉树在插入有序元素后，二叉树退化为线性，如插入1,2,3,4,5
得到的二叉树如下图：
1
-2
--3
---4
----5
此时查找元素的时间无法达到logn
因此想到一下解决办法：
1.使用平衡二叉树AVL
优点：对于任意序列的元素（不只是有序序列）插入都可达到查找时间复杂度logn
缺点：当由于学习的代价大，而且在插入删除操作复杂，不适合小的项目
2.使用红黑树
同上
3.使用Trie树
优点：使用了顺序元素有相同的前缀，不同前缀位于不同的层，得到的树基本平衡，而达到目的
缺点：需要重写编写树的代码
4.乱序插入
优点：由于BST对于随机序列的查找时间可以到达logn，所以符合项目要求，不需重写BST代码，只需在大量插入时，编写乱序随机代码
缺点：当第一次进行大量插入时可以达到效果，对于后期的顺序插入的数据无能为力，但可在后期插入的顺序元素比较多后，重建二叉树

因此采用方案4



---
#线段树
[线段树](http://blog.csdn.net/metalseed/article/details/8039326)



---
#RBtree
[RB-tree](http://blog.csdn.net/v_july_v/article/category/774945)


---
#红黑树

---
#B-tree









