#ProgramPearls
----
#C1
##位图数据结构
有限域的稠密集，无重复或关联（如有可用表实现）

多通道算法

##时间空间的权衡
时间可以节省空间
空间减少，也要求时间减少
相互改善为首选，只有初始设计与最优状态相差较多才有可能
初始化大量空间也需要时间

##简单设计
不能再增加，不能再减少
简单->可靠、安全、健壮、有效

-----
#C2啊哈算法

#2.2 二分查找

#2.3 原语

ab交换，ab为字符串的两部分
ab1br -> b1bra  递归交换 b1 br

a^rb - a^rb^r - (a^rb^r)^r

#2.4 归拢：排序
变位词
签名/hash

#2.5原则
排序
二分
签名

转置40000x40000矩阵

顺序查找n
排序+二分nlogn+logn

---
#C3 数据结构程序
选用合适的数据结构，减少重复
数组
高级工具
封装

---
#C4 编写正确的程序
程序验证
黑豆、白豆：
-2w +b  = +b -2w
-2b +b  = -b
-w-b +w = -b
-b-w +w = -b

---
#C5 次要问题
测试、断言、自动化测试、计时


---
#C6 性能透视
数据结构，算法
系统独立性代码优化
系统依赖性代码优化
硬件

#C7 封底计算
估算
量纲
经验法则
    y年 利率r%
    r*y=72
    一年3.155*10^7
7.4 利特尔法则 
总成本=单位成本X个数
系统中物体的平均数量=物体离开系统的平均比率X每个物体在系统中所花费的平均时间

r 响应时间
平均思考时间z的n个用户
思考-等待响应 循环
n 总作业数 平均负载
x 吞吐量
n=(z+r)*x
r=n/x-z

---
#C8 算法设计技术
#8.1 问题和简单算法
分治法

算法设计
保存状态，避免重新计算
将信息预处理到数据结构中
DP算法
扫描算法
累积表
下限

---
#C9 代码优化
##使用开销更小的运算符
如移位代替* /，加减代替%
##宏、函数、内联
##循环展开
避免流水线阻塞，减少分支，增加指令级并行
##扩展数据结构
经纬度点转为数组
##根据已知条件，增加更多展开判断

##保存中间结果
##懒惰计算
除非需要，否则不计算某个元素
##时间换空间
压缩

##原则
效率的角色：不成熟的优化危及程序正确性、功能性、可维护性
度量工具：
设计层次：
加速的另一面是减慢

---
#C10 压缩空间
##数据空间技术
* 不要保存，重新计算     
generator
急剧减小保存此类对象空间
适用：有规律对象，随机生成器
用途：网络传输，空间有限

* 稀松数据结构        
稀松矩阵

* 数据压缩      

* 分配策略      
需要时才分配

* 垃圾回收      
高速缓存敏感的内存布局

##10.4 编码空间技术
* 解释器       
* 转换成机器语言

##10.5 原则
* 空间成本      
热点数据
* 度量空间      
性能监视器
* 权衡
性能、功能、可维护性
* 和环境协作


---
#P3产品
#C11 排序
##11.1 插入排序
```
for i=[1,n)
    for (j=i;j>0 && x[j-1]>x[j]; j--)
        swap(j-1,j)

for i=[1,n)
    t=x[i]
    for (j=i;j>0 && x[j-1]>x[j]; j--)
        x[j]=x[j-1]
    x[j]=t
```
```python
l=[3,1,4,2,6,8,5]
def insertSortInplace(l):
    for i in range(1,len(l)):
        for j in range(0,i):
            if l[i]<l[j]:
                tmp=l[i]
                for k in range(i,j,-1):
                    l[k]=l[k-1]
                l[j]=tmp
                break

insertSortInplace(l)
print l
```
##11.2 快速排序
```
voie qsort3(l,u)
    if l>=u
        return
    t=x[l];i=l;j=u+1
    loop
        do i++ while i<=u && x[i]<t
        do j-- while x[j] > t
        if i>j
            break
        swap(i,j)
    swap(l,j)
    qsort3(l,j-1)
    qsort3(j+1,u)


voie qsort4(l,u)
    if u-l<cutoff
        return
    swap(l,randint(l,u))
    t=x[l];i=l;j=u+1
    loop
        do i++ while i<=u && x[i]<t
        do j-- while x[j] > t
        if i>j
            break
        temp=x[i];x[i]=x[j];x[j]=temp
    swap(l,j)
    qsort4(l,j-1)
    qsort4(j+1,u)
```
























