#TCP协议
---
#docs
[TCP 的那些事儿（上）](http://kb.cnblogs.com/page/209100/)
[TCP协议中的三次握手和四次挥手(图解)](http://blog.csdn.net/whuslei/article/details/6667471)



---
#协议字段
Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。
Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。
Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。
TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。




---
#协议流程
##三次握手
第一次握手发送一个序列号；
第二次握手的序列号是单独发送的，第二次握手的确认号是第一次握手序列号+1；
第三次握手的序列号是第二次握手的确认号，第三次握手的确认号是是第二次握手的序列号+1；
```
                                  发送                  确认
第一次：SYN=1       SEQ=X               ACK=0（客）
第二次：SYN=1       SEQ=Y              ACK=X+1（服）
第三次：                  SEQ=X+1          ACK=Y+1（客）
SYN 同步位
```
在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.


实例:
IP 192.168.1.11敏感词37 > 192.168.1.123.7788: S 3626544836:3626544836
IP 192.168.1.123.7788 > 192.168.1.11敏感词37: S 1739326486:1739326486 ack 3626544837
IP 192.168.1.11敏感词37 > 192.168.1.123.7788: ack 1739326487,ack 1
第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;
第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;
第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。

即：第三次发送的序列号是第二次发的确认号，第三次发送的确认号是第二次发送序列号+1； 



---
#拥塞避免和慢启动
当拥塞发生时（超时或收到重复确认），慢启动门限ssthresh被设置为当前拥塞窗口cwnd大小（题目为16）的一半，即8。同时cwnd重置为1。新的数据被接收，则cwnd增加，规则为ssthresh之前，慢启动，即cwnd指数增长；到达ssthresh之后，拥塞避免，即cwnd加1。





---
#TCP参数
##SO_KEEPALIVE
[UNIX网络编程——socket的keep-alive](http://blog.csdn.net/ctthuangcheng/article/details/8596818)
SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。
设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方 发一个保持存活探测分节(keepalive probe)。
这是一个对方必须响应的TCP分节.它会导致以下三种情况：
    对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。
    对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。
    对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为 EHOSTUNREACH。
根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。   
keepAlive = 1;
Setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&keepAlive, sizeof(keepAlive));
如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，
一种是修改内核关于网络方面的 配置参数，
另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。

tcp自己的keepalive有这样的一个bug：
正常情况下，连接的另一端主动调用colse关闭连接，tcp会通知，我们知道了该连接已经关闭。但是如果tcp连接的另一端突然掉线，或者重启断电，这个时候我们并不知道网络已经关闭。而此时，如果有发送数据失败，tcp会自动进行重传。重传包的优先级高于keepalive，那就意味着，我们的keepalive总是不能发送出去。 而此时，我们也并不知道该连接已经出错而中断。在较长时间的重传失败之后，我们才会知道。

为了避免这种情况发生，我们要在tcp上层，自行控制。对于此消息，记录发送时间和收到回应的时间。如果长时间没有回应，就可能是网络中断。如果长时间没有发送，就是说，长时间没有进行通信，可以自行发一个包，用于keepalive，以保持该连接的存在。

##SO_REUSEADDR SO_REUSEPORT
[socket编程：SO_REUSEADDR例解](http://www.sudu.cn/info/html/edu/20050101/296180.html)
[socket中的SO_REUSEADDR ](http://blog.sina.com.cn/s/blog_53a2ecbf010095db.html)
[关于Linux下SO_REUSEADDR的疑问？](http://bbs.csdn.net/topics/300002611)
一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。
SO_REUSEADDR用于对TCP套接字处于TIME_WAIT状态下的socket，才可以重复绑定使用。
server程序总是应该在调用bind()之前设置SO_REUSEADDR套接字选项。
TCP，先调用close()的一方会进入TIME_WAIT状态

2、SO_REUSEADDR和SO_REUSEPORT
SO_REUSEADDR提供如下四个功能：
* SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。
* SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。
* SO_REUSEADDR允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。这一般不用于TCP服务器。
* SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。

SO_REUSEPORT选项有如下语义：
此选项允许完全重复捆绑，但仅在想捆绑相同IP地址和端口的套接口都指定了此套接口选项才行
如果被捆绑的IP地址是一个多播地址，则SO_REUSEADDR和SO_REUSEPORT等效。

使用这两个套接口选项的建议：
在所有TCP服务器中，在调用bind之前设置SO_REUSEADDR套接口选项；
当编写一个同一时刻在同一主机上可运行多次的多播应用程序时，设置SO_REUSEADDR选项，并将本组的多播地址作为本地IP地址捆绑。
if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,(const void *)&nOptval , sizeof(int)) < 0) ...

附
Q:编写 TCP/SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？
A:这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息，指明"地址已经使用中"。如果你的服务程序停止后想立即重启，而新套接字依旧使用同一端口，此时SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。
一个套接字由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端口。SO_REUSEADDR 仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的。所以，重启后的服务程序有可能收到非期望数据。必须慎重使用SO_REUSEADDR 选项。【2】








#Nagle算法
[再次谈谈TCP的Nagle算法与TCP_CORK选项](http://blog.csdn.net/dog250/article/details/21303679)
避免发送"大量"的小包
Nagle算法的初衷：避免发送大量的小包，防止小包泛滥于网络，理想情况下，对于一个TCP连接而言，网络上每次只能一个小包存在。它更多的是端到端意义上的优化。
CORK算法的初衷：提高网络利用率，理想情况下，完全避免发送小包，仅仅发送满包以及不得不发的小包。

##关于交互式应用
一直以来，人们有个误区，那就是Nagle算法会为交互式应用引入延迟，建议交互式应用关闭Nagle算法。
事实上，正是交互式应用引入了大量的小包，Nagle算法所作用的正是交互式应用！
引入一些延迟是必然的，毕竟任何事都要有所代价，但是它更多的是解决了交互式应用产生大量小包的问题，不能将那么一点点为解决问题所付出的代价作为新的问题而忽视了真正的问题本身！

##TCP的Nagle算法和延迟ACK
Nagle算法的操作过程请参看Wiki，它减少了大量小包的发送，实际上就是基于小包的停-等协议。在等待已经发出的包被确认之前，发送端利用这段时间可以积累应用下来的数据，使其大小趋向于增加。这是避免糊涂窗口综合症的一种有效方法，请注意，糊涂窗口指的是接收端的糊涂，而不是发送端的糊涂，接收端不管三七二十一得通告自己的接收窗口大小，丝毫不管这会在发送端产生大量小包。然而发送端可以不糊涂，你通告你的，我就是不发，你糊涂我不糊涂，你不断通告很小的数值，我不予理睬，我有自己的方法，直到收到已经发出包的ACK才会继续发送，这就是Nagle算法的糊涂抵制方案。


