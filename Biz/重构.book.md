
# 重构 笔记

# C1 第一个案例
什么时候重构：添加新特性时，现有的代码结构无法很方便的达成目的

## 1.2 重构第一步
核对是否有测试，没有则添加
	添加则涉及到对原本业务的梳理
自我检测能力

## 1.3 分解并重组statement
提炼函数 extractMethod
	找到局部变量 和参数
修改变量名：好的名字 更容易让其他人理解
移动函数到对应上下文，原来调用点改为委托调用
去除临时变量，改为查询函数，

## 1.4 多态取代switch
最好不要在另一个对象基础属性上运用switch，不得不用，最好在对象自己的数据上用

一部影片可以在生命周期内修改分类，一个对象不能修改所属的类
State模式，抽出 price类，可以使movie动态修改价格

重构的节奏：测试->小修改->测试->小修改...

---
# C2 重构原则
## 2.1 什么是重构
（名词）对软件内部结构的一种调整，目的是不改变软件可观察行为的前提下，提高理解性，降低修改成本
（动词）使用一系列重构收发，在不改变软件可观察行为的前提下，调整其结构

两顶帽子：
添加新功能，重构
不要同时进行，添加新功能时，需要添加测试
重构时，不要添加功能，只改进结构，必要时修改测试

## 2.2 为何重构
不是银弹
### 改进软件设计
维持当初的设计
消除重复代码，确定的事物和行为只在代码中表述一次
### 更容易理解
看的更远
### 帮助找到bug
更深入的理解代码
### 提高编程速度
良好的设计是快速开发的根本

## 2.3 何时重构
不必特别抽出时间去做
三次法则
添加功能时
	无法快速添加
修补错误时
	不能清晰到一眼看出bug
code review
	
难以修改的原因：
难以阅读
逻辑重复
添加新行为要改旧代码
复杂逻辑

## 2.4 怎么对经理说
间接层的价值
* 允许逻辑共享
* 分开解释意图和实现
* 隔离变化
* 封装条件逻辑，多态消息

## 2.5 重构的难题
### 数据库
增加分隔层，分离库模型和对象模型，但是会增加系统复杂度；因此可以留到对象不稳定时再添加
### 修改接口
已经发布的接口，调用新接口
### 难以通过重构完成的设计改动
### 何时不该重构
改动太大，成本高到还不如重写一份
现有代码不能正常运作
时间不够

## 2.6 重构与设计
软件可塑性更强
一种观点：重构可以取代预先设计
但没有重构，就必须花很大时间和精力到预先设计上

需要预先设计，不必找到一个正确的完美的，而需要一个合理的解决方案

灵活性需要代价：
建造一个灵活的解决方案，成本难以估算，如果在可能变化点都建立灵活性，复杂度和维护难度都大大提高

## 2.7 重构与性能
先写出可调的软件，再调整获得足够速度
时间预算法，最严格
持续关注法，一旦性能改善分散到个个角落，每次改善都只是对程序行为的一个狭隘视角出发
2-8法则
利用上述90%的统计数据

短期内的重构可能让系统变慢（如加入了中间层），但是后续的优化会更容易

## 2.8 重构起源何处
有效的度量系统，找到性能瓶颈

---
# C3 代码坏味道
## A 重复代码或逻辑相关
## 3.1 重复代码
相关的类，有相同代码
完全一样，提炼函数
不完全一样，分离出相似和差异部分
模板方法

不相关的类，有相同代码
提炼到独立类中

更进一步，逻辑相似

## 3.12 lazy class
多余的类应该消失

## 3.18 alternative classes with different interfaces
两个类做同一件事，但不同的签名
重复逻辑



## B 复杂度过高
## 3.2 过长函数
当感觉需要注释来说明什么的时候，就把说明的东西写进独立函数，并以用途命名。
哪怕调用动作导致函数更长
但是，关键不在于函数长度，在于函数“做什么”和 “如何做”之间的语义距离

难点：过长的参数列表
应对：replace temp with query 调用查询方法
introduce prarmeter object 对象参数
preserve whole object(288)

如果还长，则replace method with method object(135)

标志：注释、条件表达式、循环

## 3.3 过大的类

## 3.4 过长的参数列表

## 3.13 speculative generality 夸夸其他未来性
提前过度设计
如：没用的抽象类；没用的函数参数；函数名不明确

## 3.22 过多的注释
尽量用代码来说明一切

## C 高耦合
## 3.5 发散式变化
一个类受多种变化影响
正常应该 变化尽量发生在单一类中

## 3.6 霰弹式修改
一种变化要在很多不同类内做出许多小修改

期望：外界变化 和需要修改的类趋于 一一对应

## 3.7 依恋情结
数据和对数据操作行为包装在一起
将总是一起变化的东西放在一块

## 3.8 数据泥团 data clumps
数据总喜欢成群结队在一块
类似的数据可以提炼到独立对象中

## 3.9 基本类型偏执
基本类型虽然快，但是不够结构化
结构类型 可以封装一些操作，传递时也减少了参数数量

## 3.10 switch statements
问题：重复，改了一处，其他地方的switch也要改（如果只在一个地方用，可使用）
多态代替

## 3.11 平行继承体系

## 3.14 temporary field
某个变量只为特定情况而设

## 3.15 message chains 
对象请求下一个对象，不断深入
如果对象间关系发生改变，就需要作出修改
重构：观察最终对象的用途

## 3.16 middle man
过度的使用委托

## 3.17 inappropriate intimacy 
两个类过于亲密，如互相调用private
重构：合并、或者改造private；或者增加委托

## 3.19 incomplete library class 不完美的类库
类库不可能满足所有未来需求，因此需要改造
改类库代码，只改一两个函数可用 introduce foreign method(162)
如果要添加一大堆额外行为，可用introduce local extension(164)

## 3.20 data class 数据类
会被其他类过分细琐的操控
对象应该承担一定责任，而不是数据的容器

## 3.21 refused bequest 被拒绝的遗赠
子类继承父类后，但是不想要所有的 父类行为或数据
传统说法：继承设计有问题，为这个子类建立兄弟类
重构：relpace inheritance with delegation(352)


---
# C4 构筑测试体系
## 4.1 自测试代码的价值
大部分时间花在哪：找bug
确保所有测试自动完成，自己坚持测试结果
一套测试就是一个强大的bug侦测器
编写测试的时机：开始编程前，明确了要测功能做什么

## 4.2 junit
## 4.3 添加更多测试

---
# C5 重构列表
## 5.1 重构的记录格式
名称
概要
动机
做法
范例

## 5.2 寻找引用点
使用IDE

## 5.3 这些重构手法有多成熟
小步前进，频繁测试

---
# C6 重新组织函数
## 6.1 Extract method(110)
一段代码从原函数提取，放进新函数
函数长度多长合适？
关键在于函数名称和本体之间的语义距离

### 做法
命名，如果没有更有意义的名字，就别动
提代码
检查提出代码内变量及作用域
检查临时变量
检查局部变量是否被改变
调用方 整理需要传的参数

## 难点
局部变量，如果调用方还要使用，则需要返回
只是新函数用，可以replace temp with query

## 6.2 Inline method(117) 
与6.1相反
### 动机
太多的间接层导致代码混乱

## 6.3 inline temp 内联临时变量
将对该变量的引用动作，替换为对它赋值的表达式自身
### 动机
妨碍了其他重构手法，如extract method

## 6.4 replace temp with query 
将表达式提炼到一个独立函数中，这个临时变量的所有引用点替换为新函数的调用，新函数就可被其他函数使用
### 动机
减少调用方长度，更清晰
### 做法
找出只被赋值一次的临时变量
将该变量声明为final，编译以确保
将变量赋值的右侧提炼到独立函数

## 6.5 introduce explaining variable 引入解释性变量
将该复杂表达式（或其中一部分）结果放进一个临时变量，以此变量名称来解释表达式用途
### 动机
表达式有可能复杂而难以阅读
extract method难以进行时

## 6.6 split temporary variable 分解临时变量
针对每次赋值，创造一个独立、对应的临时变量
### 动机
每个变量只承担一个责任，同一个临时变量承担两件不同的事，会令代码阅读者糊涂

## 6.7 remove assignments to parameters 移除对参数的赋值
以一个临时变量取代该参数的位置
### 动机
降低了代码的清晰度，混用了按值和按引用传递

## 6.8 replace method with method object
将这个函数放进一个单独对象中，如此局部变量就成了对象内字段，你可以在同一个对象内将这个大型函数分解为多个小型函数
### 动机
局部变量泛滥
无法拆解函数，不好做 extract method

## 6.9 substitute algorithm 替换算法
将函数本体替换为另一个算法
### 动机
用更清晰替代更复杂（重写）

---
# C7 在对象之间搬移特性
对象的责任放在哪
## 7.1 move method 搬移函数
在该函数最常引用的类中建立一个有类似行为的新函数，将旧函数变成一个单纯的委托函数，或者完全移除。
### 动机
使用一个对象的次数比使用自己所驻对象的次数还多
将函数放到交流更多的对象那里

## 7.2 move field 
target class 新建一个new field，修改source field 的所有用户，令他们改用new field
### 动机
一个field在所驻class之外被另一个class中有更多函数使用

## 7.3 extract class 提炼类
建立新class将相关field和function搬移到新class
### 动机
单一职责原则
calss随着新特性增加，更加臃肿
某个class做了应该由两个classes做的事

## 7.4 inline class 类内联化
将class所有特性搬移到另一个class，然后移除原class
### 动机
一个class不再承担足够的责任

## 7.5 hide delegate 隐藏委托
在server端（某个class)建立客户所需的所有函数，隐藏委托关系
### 动机
封装：让对象少了解系统其它部分，一旦发生变化，变化的对象会更少，也更容易变化
减少因委托变化导致的变化

## 7.6 remove middle man
让客户直接调用delegate
### 动机
某个class做了过多的简单委托动作
找到合适的隐藏程度

## 7.7 introduce foreign method 引入外加函数
### 动机
使用的server class 需要一个额外函数，但无法修改这个class
### 做法
在client class中建立一个函数，并以一个server class 实体作为第一argument 

如果有大量外加函数，则应使用introduce local extension

## 7.8 introduce local extension 引入本地扩展
### 动机
使用的server class 需要一些额外函数，但无法修改这个class
### 做法
建立一个新class，使它包含这些额外函数，让这个扩展品成为source class的子类或wrapper

子类，更简单，必须在对象创建期实施，必须产生一个subclass对象

---
# C8 重新组织数据
## 8.1 self encapsulate field 自封装值域
### 动机
直接访问field，但field之间的耦合关系逐渐变的笨拙
直接访问：代码好读
增加get/set：可以在子类中覆写get/set
### 做法
为field建立get/set method

## 8.2 replace data value with object 以对象取代数据值
### 动机
data item需要额外的数据和行为
### 做法
将data  item 变为对象

## 8.3 change value to reference 
### 动机
有一个class，衍生出许多相等实体，希望将他们替换为单一对象
### 做法
将这个value object 变成一个reference object 

## 8.4 change reference to value 
### 动机
有一个reference object 很小且不可变，且不易管理
更方便管理，
### 做法

## 8.5 replace array with object
### 动机
有一个数组，中间元素代表不同东西
很难维护，而且需要注释或实际的数据去确定里面的具体含义
### 做法
用对象替换数组，对于每个元素用值域表示

## 8.6 duplicate observed data
### 动机
你有一些domain data置身于GUI控件中，而domain method需要访问之。
MVC模式，但是数据需要做同步处理
### 做法
将该数据拷贝到一个domain object中，建立一个observer模式，用以对domain object和GUI object内的重复数据进行同步控制

## 8.7 change unidirectional association to bidirectional 将单向关联改为双向
### 动机
两个classes都需要使用对方特性，但其间只有一条单向连接
### 做法
添加一个反向指针，并修改函数能够同时更新两条连接


## 8.8 change bidirectional  association to unidirectional  将双向关联改为单向
### 动机

### 做法

## 8.9 replace magic number with symbolic constant
### 动机
代码更清晰，减少重复修改
### 做法
符号常量取代魔法数

## 8.10 encapsulate field
### 动机
class中存在public值域
将数据和行为分开
### 做法
改为private 

## 8.11 encapsulate collection
### 动机
函数返回群集
不暴漏内部结构，隐藏与调用方无关的结构，降低耦合度
### 做法
让这个函数返回read-only view，并在这个class中提供添加/删除 collection 元素的函数 

## 8.12 replace record with data class 
### 动机

### 做法



### 动机

### 做法






































































































