#Concurrent
----
#Little's Law 
[wiki](https://en.wikipedia.org/wiki/Little%27s_law)
排队论里面的理论，只要现实问题中有排队的结构就可以考虑应用Little's Law。这里说的排队不一定要满足任何像先进先出或者先进后出的规则，队伍还不一定需要有顺序，关键是有一个系统（或者叫成空间也行）能容纳个体，个体有进有出就行

L：平均队长， W：等待时间， Lambda：到达率
L = W * Lambda
1. 必须是稳定系统，即：“人”离开的速率必须大于或等于到达的速率，否则系统中的等待数将会越来越大，队长最终趋向于无穷大。
2. 等待时间可以理解成队列中最后一个“人”加入到队列中，直到他被服务为止的时间。


---
#CSP
在该语言中，一个并发系统由若干并行运行的顺序进程组成，每个进程不能对其他进程的变量赋值。进程之间只能通过 一对通信原语实现协作：Q->x表示从进程Q输入一个值到变量x中；P<-e表示把表达式e的值发送给进程P。当P进程执行Q->x， 同时Q进程执行P<-e时，发生通信，e的值从Q进程传送给P进程的变量x

典型的算子有：→(前缀)，|(外部非确定性选择)，\e(事件隐蔽)，以及递归等。



---
#Channel模型
Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。

Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。
通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。

##与Actor模型区别
主要的区别在于：在CSP消息交换是同步的(即两个进程的执行"接触点"的，在此他们交换消息)，而Actor模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。由于Actor享有更大的相互独立,因为他可以根据自己的状态选择处理哪个传入消息。自主性更大些。
　　在Go语言中为了不堵塞进程，程序员必须检查不同的传入消息，以便预见确保正确的顺序。CSP好处是Channel不需要缓冲消息，而Actor理论上需要一个无限大小的邮箱作为消息缓冲。

---
#Actor模型
传统多数流行的语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors使用消息模型，每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors，保证了单独写原则 。从而巧妙避免了多线程写争夺。

在Actor模型中，主角是Actor，类似一种worker，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的：


特点是：
隔离计算实体
"Share nothing"
没有任何地方同步
异步消息传递
不可变的消息，消息模型类似mailbox / queue

1.本地单向异步请求Local One-Way Asynchronous Request：
从请求者发送一个异步请求到应答者，应答者不会回应。
2.超越上下文的异步请求Request Asynchronous Out-of-Context Request ，请求者发送一个消息给响应者，响应者发回返回消息，当请求者接受到响应以后必须重新建立上下文。
3.上下文内的异步外请求Request Asynchronous In-Context Request 当返回消息被请求者接受后，当时的上下文也被保留下来。




AKKA框架是一个实现Actors模型的Scala或Java平台，灵感来自ERlang，能更轻松地开发可扩展，实现多线程安全应用。
Actors是一个轻量级的对象，通过发送消息实现交互。每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors。在同一时间可以于一个Java虚拟机存在数以百万计的参与者，构架是一个分层的父层（管理）-子层，其中父层监控子层的行为。还可以很容易地扩展Actor运行在集群中各个节点之间 - 无需修改一行代码。每个演员都可以有内部状态（字段/变量），但通信只能通过消息传递，不会有共享数据结构（计数器，队列）。Akka框架支持两种语言Java和Scala

#AKKA
N[AKKA教程](http://www.jdon.com/concurrent/akka/tutorial.html)

