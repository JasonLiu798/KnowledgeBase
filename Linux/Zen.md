#Unix 编程艺术
---

#unix哲学基础
自下而上，而不是自上而下，注重实效
1 模块原则
2 清晰原则：清晰胜于机巧
3 组合原则
4 分离原则：策略同机制分离，接口同引擎分离
5 简洁原则：
6 吝啬原则：
7 透明性原则：
8 健壮原则
9 表示原则：知识叠入数据以求逻辑质朴健壮
10 通俗原则：
11 缄默原则：如果一个程序没什么好说的，就保持沉默
12 补救原则：出现异常时，立马给出足量错误信息
13 经济原则：宁花机器一分，不花程序员1秒
14 生成原则：避免手工hack，尽量编写程序去生成程序
15 优化原则：雕琢前先得有原型，跑之前先学会走
16 多样原则：绝不相信所谓不二法门的断言
17 扩展原则：设计总着眼未来，未来比预想快
KISS

软件设计有两种方式：设计的极简单，没有缺陷；设计的极复杂，有缺陷也看不出

模块分解法


#正交性
改变一个不会影响其他
减少重复


##3 SPOT原则
single point of truth

##4  紧凑性和强单一中心


#4.3 软件是多层的
自底向上
从具体到抽象

自顶向下
从抽象到具体
适合：目标明确；需求变化小；底层有自由选择；
##2 胶合层
自底向上 自顶向下结合的产物
越薄越好，策略与机制分离


面向对象
多样性原则
胶合层太重
过度分层，破坏透明性
丧失优化机会

---
#C6 透明性
减少抽象层
过度保护底层细节
不透明转换为透明
sng,tic,infomp

---
#C7 多道程序设计：分离进程为独立的功能
管道中所有程序都是并发运行
more
缺点：单向性

##对等进程间通信
临时文件
信号
###6 套接字
接收端已经收到数据，并开始使用，但是ACK还没有被发送端收到
即使不知道那些数据被接收到，也应该正常工作

共享内存
需要自行处理竞争死锁，通常在共享段中用信号量


线程，时序依赖

---
#C8微型语言
紧凑，代码少，bug少

语言分类
data format| mini language | interpreters
微语言：在某些解释性上下文，表达执行行为

---
#C9提升规格说明书层次

---
#C10 配置
提高适应力

放到哪
/etc
系统环境变量、用户环境变量
用户home
参数

---
#C11 Unix环境模式下用户接口设计模式
11.1 最小立异原则
减小学习复杂度

WYSIWYG

#接口设计模式
##过滤器模式
宽进严出
不丢弃不需要的数据
过滤时不增加无用数据
##catrip模式
无输入输出
只有状态码
##源模式
无输入，如ls ps
##接收器模式
只接收标准输入
##编译器模式
无输入，无输出，结果打印到标准错误
如gcc
##ed模式
简单交互，ftp，gdb
##roguelike模式
vi
##引擎和接口分离 模式

#11.9 沉默是金
错误发送到标准错误
屏幕纵向有限，一行垃圾信息意味着少了一行有效信息

----
#C12优化
#12.1 什么也别做
少量的常数优化会被硬件性能增长在几个月内追上
    十八个月翻一番，晚六个月就可获得26%的性能提升
更应关注O(n)数量级上的提升

#12.2 先估量，后优化
明确瓶颈所在

#12.3 非定域性之害
永远不要把核心数据结构和时间关键循环抛出缓存
缓存的大小，代码行数

#12.4 吞吐量和延迟
时延：
a.批处理事务
b.允许事务重叠
c.缓存

---
#C13 复杂度：尽可能简单，但别简单过头
#13.1 复杂度
成本
成因：
    功能蠕变
    过早优化
代码量，接口复杂度，实现复杂度
blivet

MIT
NewJersey（差的）
Worse is better




























