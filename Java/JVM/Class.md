# 类文件
[实例分析JAVA CLASS的文件结构](https://coolshell.cn/articles/9229.html)

```c
ClassFile { 
    u4 magic; 
    u2 minor_version; 
    u2 major_version;
    u2 constant_pool_count; 
    cp_info constant_pool[constant_pool_count-1]; 
    u2 access_flags; 
    u2 this_class; 
    u2 super_class; 
    u2 interfaces_count; 
    u2 interfaces[interfaces_count]; 
    u2 fields_count; field_info fields[fields_count]; 
    u2 methods_count; method_info methods[methods_count]; 
    u2 attributes_count; attribute_info attributes[attributes_count]; 
}
```

u1、u2、u4分别代表1、2、4个字节无符号数。

## magic
魔数，魔数的唯一作用是确定这个文件是否为一个能被虚拟机所接受的Class文件。魔数值固定为0xCAFEBABE
## minor_version、major_version
　　分别为Class文件的副版本和主版本。它们共同构成了Class文件的格式版本号。不同版本的虚拟机实现支持的Class文件版本号也相应不同，高版本号的虚拟机可以支持低版本的Class文件，反之则不成立。

## constant_pool_count
　　常量池计数器，constant_pool_count的值等于constant_pool表中的成员数加1。
这个容量计数是从1而不是0开始的，将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义
## constant_pool[]
常量池
主要存放：
* 字面量（Literal）
* 符号引用（Symbolic References）
	- 类和接口的全限定名（Fully Qualified Name）   
	- 字段的名称和描述符（Descriptor）   
	- 方法的名称和描述符
索引从1开始到constant_pool_count -1。

## access_flags
　　访问标志，access_flags是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。access_flags的取值范围和相应含义见下表：
```c
#define JVM_ACC_PUBLIC        0x0001  /* visible to everyone */
#define JVM_ACC_PRIVATE       0x0002  /* visible only to the defining class */
#define JVM_ACC_PROTECTED     0x0004  /* visible to subclasses */
#define JVM_ACC_STATIC        0x0008  /* instance variable is static */
#define JVM_ACC_FINAL         0x0010  /* no further subclassing, overriding */
#define JVM_ACC_SYNCHRONIZED  0x0020  /* wrap method call in monitor lock */
#define JVM_ACC_SUPER         0x0020  /* funky handling of invokespecial */
#define JVM_ACC_VOLATILE      0x0040  /* can not cache in registers */
#define JVM_ACC_BRIDGE        0x0040  /* bridge method generated by compiler */
#define JVM_ACC_TRANSIENT     0x0080  /* not persistent */
#define JVM_ACC_VARARGS       0x0080  /* method declared with variable number of args */
#define JVM_ACC_NATIVE        0x0100  /* implemented in C */
#define JVM_ACC_INTERFACE     0x0200  /* class is an interface */
#define JVM_ACC_ABSTRACT      0x0400  /* no definition provided */
#define JVM_ACC_STRICT        0x0800  /* strict floating point */
#define JVM_ACC_SYNTHETIC     0x1000  /* compiler-generated class, method or field */
#define JVM_ACC_ANNOTATION    0x2000  /* annotation type */
#define JVM_ACC_ENUM          0x4000  /* field is declared as element of enum */

#define JVM_ACC_PUBLIC_BIT        0
#define JVM_ACC_PRIVATE_BIT       1
#define JVM_ACC_PROTECTED_BIT     2
#define JVM_ACC_STATIC_BIT        3
#define JVM_ACC_FINAL_BIT         4
#define JVM_ACC_SYNCHRONIZED_BIT  5
#define JVM_ACC_SUPER_BIT         5
#define JVM_ACC_VOLATILE_BIT      6
#define JVM_ACC_BRIDGE_BIT        6
#define JVM_ACC_TRANSIENT_BIT     7
#define JVM_ACC_VARARGS_BIT       7
#define JVM_ACC_NATIVE_BIT        8
#define JVM_ACC_INTERFACE_BIT     9
#define JVM_ACC_ABSTRACT_BIT      10
#define JVM_ACC_STRICT_BIT        11
#define JVM_ACC_SYNTHETIC_BIT     12
#define JVM_ACC_ANNOTATION_BIT    13
#define JVM_ACC_ENUM_BIT          14
```

## this_class u2
　　类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info类型常量，表示这个Class文件所定义的类或接口。
## super_class u2
　　父类索引，对于类来说，super_class的值必须为0或者是对constant_pool表中项目的一个有效索引值。如果它的值不为0，那constant_pool表在这个索引处的项必须为CONSTANT_Class_info类型常量，表示这个Class文件所定义的类的直接父类。当然，如果某个类super_class的值是0，那么它必定是java.lang.Object类，因为只有它是没有父类的。
## interfaces_count u2
接口计数器，interfaces_count的值表示当前类或接口的直接父接口数量。
## interfaces[]
　　接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值，它的长度为interfaces_count。每个成员interfaces[i] 必须为CONSTANT_Class_info类型常量。

## fields_count
字段计数器，fields_count的值表示当前Class文件fields[]数组的成员个数。
access_flags
name_index和descriptor_index
都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符

## fields[]
字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。

## methods_count
方法计数器，methods_count的值表示当前Class文件methods[]数组的成员个数。
## methods[]
方法表，methods[]数组中的每个成员都必须是一个method_info结构的数据项，用于表示当前类或接口中某个方法的完整描述。
访问标志（access_flags）
名称索引（name_index）
描述符索引（descriptor_index）
属性表集合（attributes）
## attributes_count
属性计数器，attributes_count的值表示当前Class文件attributes表的成员个数。
## attributes[]
属性表，attributes表的每个项的值必须是attribute_info结构。

## code

StackMapTable属性中包含零至多个栈映射帧（Stack MapFrames），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。

Signature属性在JDK 1.5发布后增加到了Class文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。

BootstrapMethods属性在JDK 1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。


---
# <init> <clinit>
<init>

Java在编译之后会在字节码文件中生成<init>方法，称之为实例构造器，该实例构造器会将语句块，变量初始化，调用父类的构造器等操作收敛到<init>方法中，收敛顺序（这里只讨论非静态变量和语句块）为： 
1. 父类变量初始化 
2. 父类语句块 
3. 父类构造函数 
4. 子类变量初始化 
5. 子类语句块 
6. 子类构造函数

所谓收敛到<init>方法中的意思就是，将这些操作放入到<init>中去执行

<clinit> 
Java在编译之后会在字节码文件中生成<clinit>方法，称之为类构造器，类构造器同实例构造器一样，也会将静态语句块，静态变量初始化，收敛到<clinit>方法中，收敛顺序为： 
1. 父类静态变量初始化 
2. 父类静态语句块 
3. 子类静态变量初始化 
4. 子类静态语句块

<clinit>方法是在类加载过程中执行的，而<init>是在对象实例化执行的，所以<clinit>一定比<init>先执行。所以整个顺序就是： 
1. 父类静态变量初始化 
2. 父类静态语句块 
3. 子类静态变量初始化 
4. 子类静态语句块 
5. 父类变量初始化 
6. 父类语句块 
7. 父类构造函数 
8. 子类变量初始化 
9. 子类语句块 
10. 子类构造函数







































