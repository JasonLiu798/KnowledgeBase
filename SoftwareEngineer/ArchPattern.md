#架构模式
---
#分层
横向分离系统
##好处：
每一层对上层隐藏下层实现
按层来理解系统
层的实现可替换，只要提供服务相同
降低层间依赖
利于标准化
底层可以多个上层提供服务
每增加一层会降低性能

挑战：
确定层的职责
合理规划边界和接口，维持接口不变，禁止跨层调用、逆向调用

三个层次：
表现
领域
数据源

普遍原则，数据源和领域层一定不要依赖于表现层
领域逻辑和其他逻辑
表现层中领域逻辑的取舍

---
#分割
纵向分离系统
分离不相关业务组件

---
#分布式
分布式应用
分布式存储
分布式静态资源，各资源独立域名
分布式计算，搜索、流式计算
##问题
RPC开销
服务器数量增加，宕机几率增加
数据一致性
开发管理困难

---
#集群
多台服务器部署相同应用
提供更好得并发性、可用性

---
#缓存
CDN
反向代理
本地缓存
分布式缓存
前提：数据访问热点不均衡，部分数据频繁访问；
数据在一定时间内有效
##异步
可用性：消息可堆积在队列
响应速度：不用等消费者处理完就返回
消除并发访问高峰：
##冗余
##自动化
发布
代码管理
测试
安全检测部署
监控
报警
失效转移
失效恢复
降级
分配资源
##安全






---
#C2领域逻辑的组织
事务脚本
领域模型：不是由过程来控制逻辑，而是每个对象来负责一部分逻辑
    服务层：服务层逻辑和领域模型逻辑的取舍
        折衷：控制器-实体 风格
表模块

---
#C3映射到关系数据库

一致性问题：
    工作单元：一个控制对象，它复杂跟踪数据的读取、修改和存储的情况。防止同一个数据被同时读取、多个用户在同时操作同一条数据。它充当了数据映射器的控制器。在没有工作单元的时候，由领域类来充当这个控制器的。它其实是领域逻辑里面分解出来的，专门负责数据一致性控制的控制对象。
ORM

继承关系如何映射到库
类表继承，通过join连接，损失性能
具体表继承，改动困难
单表继承
3.5 建立映射
    两步映射
3.6 使用元数据
3.7 数据库连接

---
#C4 web表现层

---
#C5并发
更新丢失
不一致读
#5.2 执行语境
请求
会话，客户端与服务器端一次长时间交互，一系列逻辑相关请求构成
进程，线程，事务

#5.3 隔离与不变性
锁
不变即可共享，不需要并发控制

#5.4 乐观与悲观并发策略
乐观策略-冲突检测-冲突少，后果不严重
悲观策略-冲突避免

5.4.1 避免不一致读
乐观锁
时序读，完整的时序列表，代价昂贵

#5.5 事务
5.5.1 ACID
5.5.2 事务资源
锁升级
5.5.3 减少事务隔离 提高灵活性
可串行化：并发执行结果与以某种执行顺序依次执行结果相同
    无法保证多次执行结果相同
可重复读：允许幻读
    部分有效
读已提交：允许不可重复读
读未提交：允许脏读

5.5.4 业务事务和系统事务
系统事务：由db和事务监视器支持的事务
业务事务：跟业务相关的一系列操作，保证一致性
    单个系统事务中执行完整的业务事务，但是业务事务需要多次请求完成，产生长系统事务
长事务：失去可伸缩性，
改成短事务，复杂且不好理解，需要自行提供ACID支持，离线并发
业务事务-最容易-原子性，隔离性
业务事务-最麻烦-隔离性，没有隔离就没有一致性

#5.6 离线并发控制的模式
除非系统事务无法满足要求
乐观离线锁，首选，容易编程实现，只能在提交事务时，才发现事务将要失败，但有时，发现失败的成本很大，用户体验差
悲观离线锁，难以编程实现，降低灵活性
粗粒度锁，一组对象为单位
隐含锁，
需求阶段考虑是否考虑并发：选择悲观和乐观影响用户体验，需要领域信息，因此需要

#5.7 应用服务器并发
每会话一进程
    好处：隔离
    缺点：大量资源消耗，进程池
每会话一线程
    好处：资源消耗小
    缺点：没有隔离-创建和进入隔离区（synchronized)

---
#C6 会话状态
#6.1 无状态的价值
#6.2 会话状态
#6.3 存储会话状态的方法
客户会话状态，cookie,url,表单隐藏域
    考虑：带宽，安全，完整
服务器会话状态，内存，序列化-文件，db
数据库会话状态，

会话迁移，更好的均衡服务器负载，
服务器亲和，代理会导致不平均分布

---
#C7 分布策略
#7.1 分布对象的诱惑
#7.2 远程接口和本地接口
本地接口，进程内调用，进程间调用，跨机器调用，之间速度差一个数量级
分布对象设计第一定律：不要分布使用对象
不同节点部署同一应用的多个拷贝

#7.3 必须使用分布的情况
客户机和服务器之间
服务器和数据库之间
web

#7.4 关于分布边界
远程外观
DTO

#7.5 分布接口
soap
webservice

---
#C8 通盘考虑
持续集成
测试驱动开发
重构
#8.1 从领域层开始
事务脚本
    对复杂逻辑支持不够，
表模块
    折衷
领域模型
    缺点：难以学会；数据库连接

#8.2 深入到数据源层
事务脚本的数据源

#8.3 表现层

#8.4 具体技术的建议
实体bean本地化，细粒度接口
远程接口一般为粗粒度

#8.5 其他分层方式
Brown模型
表现层；控制/中介层；领域层；数据映射层；数据源层

Marnescu五层结构
表现层
应用层
服务层
领域层
持久层

服务层与领域层的分离

nilsson
顾客层       |   表现层
顾客帮助层    |  表现层（应用控制器）
应用层        |  领域层 服务层
领域层        |  领域层 领域模型层
持久访问层     | 数据源层
公共存储过程层 | 数据源层（可能包含一些领域层）
私有存储过程层 | 数据源层（可能包含一些领域层）

---
#P2 模式
#C9 领域逻辑模式
#9.1 事务脚本
使用过程来组织业务逻辑，每个过程处理来自表现层的单个请求
命令模式

缺点：很难给出分界点，

9.1.3 收入确认问题
合同、服务时间、规则繁多

#9.2 领域模型
合并了行为和数据的领域的对象模型
9.2.1 运行机制
对象组成的层：
    业务活动数据 对象
    业务规则 对象
    混合数据和处理过程

简单领域模型
    与数据库设计相似
    ActiveRecord
复杂领域模型
    继承、策略、其他模式
    数据映射器

如希望多次服务器调用都使用同一对象图，必须将服务器状态保存在某处

java实现：
“重进入”的概念是：当一个实体被调用时候（状态发生了变化），或者它调用其他任何对象的时候，另外一个对象再来调用该实体，那么调用的对象应该得到该实体的初始状态。

9.2.2 时机
系统复杂度

9.2.4收入确认例子

#9.3 表模块
一个对象处理所有订单
1 运行机制
表模块无标示符，需要传入标示符，通常为主键
2 使用时机
依赖于以表方式组织的数据
没有多态

#9.4 服务层
服务层来定义应用程序边界，在服务层建立一组可用的操作集合，并在每个操作内部协调应用程序响应
1 运行机制
业务逻辑种类：
    领域逻辑
    应用逻辑，工作流逻辑
2 实现方法
3 是否远程
4 识别服务与操作

9.4.2 使用时机
什么时候不用：业务逻辑只有一种客户

---
#C10 数据源架构模式
#10.1 表数据入口
充当数据库表访问入口的对象，一个实例处理表中所有行
1 运行机制
无状态
映射
    传递时使用，破坏了编译时检查
DTO
    需要创建的开支

2 使用时机

#10.2 行数据入口
充当数据源中单条记录入口的对象，每行一个实例

#10.3 活动记录
一个对象，他包装数据库表或视图中某一行，分装数据库访问，并在这些数据上增加了领域逻辑

#10.4 数据映射器
在保持对象和数据库彼此独立的情况下，在二者之间移动数据的一个映射器层
延迟加载

映射领域对象的域
    丰富构造函数：
        防止循环引用
    空对象：

处理查找
    延迟加载
把数据映射到领域对象的域

10.4.2 使用时机
数据库方案和对象需要彼此独立演变时
代价：引入新层

----
#C11对象-关系行为模型
#11.1工作单元
维护受业务事务影响的对象列表，并协调变化的写入和并发问题的解决
##1 运行机制
调用者注册
    运行改变对象又不写入库
对象注册
    在适当地方加入注册调用代码
工作单元控制器
    提交时比较变化
拓扑排序，决定更新顺序
##2 使用时机
记录操作过的各种对象，以便知道为了使内存中的数据与数据库同步需要考虑哪些对象
为了减少库调用，需要跟踪变化

#11.2标识映射
通过在映射中保存每个已经加载的对象，确保每个对象只加载一次。当要访问对象时，通过映射来查找他们

#11.2.1运行机制

#11.2.2 使用时机
db的高速缓存
防止使用相等测试的错误形式

---
#11.3延迟加载
一个对象，虽然不包含所需要的所有数据，但是知道怎么获取这些数据
##11.3.1 运作机制
null标记为加载的域
但如果Null为合法值，则需要其他符号标记
虚代理
波动加载
值保持器

---
#12 对象-关系结构模式
#12.1 标识域
为了在内存对象和数据库行之间维护标示而在对象内保存的一个数据库标示域
键表
    中央节点生成主键，一次取N个，增加性能，但出问题后会浪费N个
序列+触发器

#12.2外键映射
把对象之间的关系映射到表间的外键引用

#12.3 关联表映射
把关联保存为一个表，带有指向表的外键
多-多

#12.4依赖映射
让一个类为部分类执行数据库映射
有些对象很自然的在其他对象上下文中出现
前置条件：
每个依赖者恰好有一个所有者
不能有任何除所有者之外的对象拥有对依赖者的引用

#12.5 嵌入值
把一个对象映射成另一个对象表的若干字段

#12.6 序列化lob
将多个对象序列化到一个大对象中来保存一个对象图，并存储在数据库字段中
BLOB二进制形式
CLOB文本字符形式

#12.7 单表继承
将类的继承层次表示为一个单表，表中各列代表不同类中的所有域
单表继承

#12.8 类表继承

#12.9 具体表继承
用每个具体类对应一个表来表示类的继承层次
叶表继承

#12.10 继承映射器
用来组织可以处理继承层次的数据库映射器的一种结构

---
#C13对象-关系元数据映射模式
#13.1 元数据映射
在元数据中保持关系-对象映射的详细信息
运行机制：
    代码生成
    反射编程

#13.2查询对象
描述一次数据库查询的对象
Criteria

#13.3 资源库
协调领域和数据映射层，利用类似于集合的接口来访问领域对象

---
#C14web表现层
#14.1模型-视图-控制器
从模型中分离表现层
    表现依赖模型，模型不依赖表现
从视图中分离控制器

---
#C15分布模式
#15.1 远程外观 remote facade
为细粒度对象提供粗粒度外观来改进网络上的效率
无状态：
    组成池，提高资源利用率和效率
有状态：
    库、服务器

领域模型

DTO
    序列化方式
        文本：可读、易学；性能
        二进制：很小错误会导致通信丢失，脆弱；使用字典序列化 容错、弹性
组装器：DTO到领域模型

---
#C16离线并发模式
#16.1乐观离线锁
通过冲突检测和事务回滚防止并发业务事务中的冲突
管理冲突：
    增加版本号、谁在最后修改了信息
    where子句中对所有字段进行检查
    不一致读：对所有读取的信息都做不一致检查
    粗粒度锁
使用时机：
    冲突率低；悲观锁代价很高时
    要考虑什么时候乐观锁还不够

#16.2悲观离线锁
每次只允许一个业务事务访问数据以防止并发业务事务中的冲突
从一开始就避免了冲突
使用时机：
    冲突率高的并发会话中
    冲突处理代价很高的情况下

#16.3 粗粒度锁
用一个锁锁住一组相关的对象
运行机制：
    为一组对象建立一个控制点
    乐观锁：共享一个版本号
    悲观锁：共享某种锁标记

#16.4 隐含锁
允许框架或层超类型代码来获取离线锁

---
#C17 会话状态模式
#17.1 客户会话状态
将会话状态保存在客户端
URL参数、表单隐藏域、cookie

#17.2服务器会话状态
将会话状态以序列化形式存放在服务端
session
文件：xml、二进制（类更新后版本问题、不可读）
数据库
缓存服务器

#17.3 数据库会话状态
将会话数据作为已提交的数据保存到数据库中
isPending字段
临时表

---
#C18基本模式
#18.1 入口gateway
入口是一个封装外部系统或资源访问的对象
wrapper模式

#18.2映射器Mapper
在两个独立对象之间建立通信对象

#18.3层超类型layer supertype
某一类型充当一层中所有类型的超类型

#18.4分离接口separated interface
在一个包种定义接口，而在另一个与这个包分离的包中实现这个接口

#18.5注册表
一个众所周知的对象，其他对象可以通过该对象找到公共的对象和服务

#18.6值对象
简单对象，判等时并不根据标识ID
引用对象判等基于内部标识
另其不可变

#18.7货币
表示一个货币值
浮点带来舍入问题
关于舍入：
    置之不理
    最后一笔钱为资金总额与已分配资金的差额，误差累计到最后那笔资金
    允许货币类的用户调用方法生命取整方式，导致代码复杂
    分配器函数：指明一种分配比例的数字，返回一组分配后的金额，抱枕没有一分钱误差，所有误差以伪随机方式分配到每笔资金中

#18.8特殊情况
针对特殊情况提供特殊行为的子类
空值类
无限类
使用时机：当系统有多处地方需要在对某一特定类的实例进行条件检测，然后做相似的动作

#18.9插件 plugin
在配置时，而非编译时连接类

#18.10服务桩service stub
在测试时移除对有问题服务的依赖

#18.11记录集record set
表格数据在内存中的表现方式






































































