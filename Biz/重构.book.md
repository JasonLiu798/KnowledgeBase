
# 重构 笔记

# C1 第一个案例
什么时候重构：添加新特性时，现有的代码结构无法很方便的达成目的

## 1.2 重构第一步
核对是否有测试，没有则添加
	添加则涉及到对原本业务的梳理
自我检测能力

## 1.3 分解并重组statement
提炼函数 extractMethod
	找到局部变量 和参数
修改变量名：好的名字 更容易让其他人理解
移动函数到对应上下文，原来调用点改为委托调用
去除临时变量，改为查询函数，

## 1.4 多态取代switch
最好不要在另一个对象基础属性上运用switch，不得不用，最好在对象自己的数据上用

一部影片可以在生命周期内修改分类，一个对象不能修改所属的类
State模式，抽出 price类，可以使movie动态修改价格

重构的节奏：测试->小修改->测试->小修改...

---
# C2 重构原则
## 2.1 什么是重构
（名词）对软件内部结构的一种调整，目的是不改变软件可观察行为的前提下，提高理解性，降低修改成本
（动词）使用一系列重构收发，在不改变软件可观察行为的前提下，调整其结构

两顶帽子：
添加新功能，重构
不要同时进行，添加新功能时，需要添加测试
重构时，不要添加功能，只改进结构，必要时修改测试

## 2.2 为何重构
不是银弹
### 改进软件设计
维持当初的设计
消除重复代码，确定的事物和行为只在代码中表述一次
### 更容易理解
看的更远
### 帮助找到bug
更深入的理解代码
### 提高编程速度
良好的设计是快速开发的根本

## 2.3 何时重构
不必特别抽出时间去做
三次法则
添加功能时
	无法快速添加
修补错误时
	不能清晰到一眼看出bug
code review
	
难以修改的原因：
难以阅读
逻辑重复
添加新行为要改旧代码
复杂逻辑

## 2.4 怎么对经理说
间接层的价值
* 允许逻辑共享
* 分开解释意图和实现
* 隔离变化
* 封装条件逻辑，多态消息

## 2.5 重构的难题
### 数据库
增加分隔层，分离库模型和对象模型，但是会增加系统复杂度；因此可以留到对象不稳定时再添加
### 修改接口
已经发布的接口，调用新接口
### 难以通过重构完成的设计改动
### 何时不该重构
改动太大，成本高到还不如重写一份
现有代码不能正常运作
时间不够

## 2.6 重构与设计
软件可塑性更强
一种观点：重构可以取代预先设计
但没有重构，就必须花很大时间和精力到预先设计上

需要预先设计，不必找到一个正确的完美的，而需要一个合理的解决方案

灵活性需要代价：
建造一个灵活的解决方案，成本难以估算，如果在可能变化点都建立灵活性，复杂度和维护难度都大大提高

## 2.7 重构与性能
先写出可调的软件，再调整获得足够速度
时间预算法，最严格
持续关注法，一旦性能改善分散到个个角落，每次改善都只是对程序行为的一个狭隘视角出发
2-8法则
利用上述90%的统计数据

短期内的重构可能让系统变慢（如加入了中间层），但是后续的优化会更容易

## 2.8 重构起源何处
有效的度量系统，找到性能瓶颈

---
# C3 代码坏味道
## A 重复代码或逻辑相关
## 3.1 重复代码
相关的类，有相同代码
完全一样，提炼函数
不完全一样，分离出相似和差异部分
模板方法

不相关的类，有相同代码
提炼到独立类中

更进一步，逻辑相似

## 3.12 lazy class
多余的类应该消失

## 3.18 alternative classes with different interfaces
两个类做同一件事，但不同的签名
重复逻辑



## B 复杂度过高
## 3.2 过长函数
当感觉需要注释来说明什么的时候，就把说明的东西写进独立函数，并以用途命名。
哪怕调用动作导致函数更长
但是，关键不在于函数长度，在于函数“做什么”和 “如何做”之间的语义距离

难点：过长的参数列表
应对：replace temp with query 调用查询方法
introduce prarmeter object 对象参数
preserve whole object(288)

如果还长，则replace method with method object(135)

标志：注释、条件表达式、循环

## 3.3 过大的类

## 3.4 过长的参数列表

## 3.13 speculative generality 夸夸其他未来性
提前过度设计
如：没用的抽象类；没用的函数参数；函数名不明确

## 3.22 过多的注释
尽量用代码来说明一切

## C 高耦合
## 3.5 发散式变化
一个类受多种变化影响
正常应该 变化尽量发生在单一类中

## 3.6 霰弹式修改
一种变化要在很多不同类内做出许多小修改

期望：外界变化 和需要修改的类趋于 一一对应

## 3.7 依恋情结
数据和对数据操作行为包装在一起
将总是一起变化的东西放在一块

## 3.8 数据泥团 data clumps
数据总喜欢成群结队在一块
类似的数据可以提炼到独立对象中

## 3.9 基本类型偏执
基本类型虽然快，但是不够结构化
结构类型 可以封装一些操作，传递时也减少了参数数量

## 3.10 switch statements
问题：重复，改了一处，其他地方的switch也要改（如果只在一个地方用，可使用）
多态代替

## 3.11 平行继承体系

## 3.14 temporary field
某个变量只为特定情况而设

## 3.15 message chains 
对象请求下一个对象，不断深入
如果对象间关系发生改变，就需要作出修改
重构：观察最终对象的用途

## 3.16 middle man
过度的使用委托

## 3.17 inappropriate intimacy 
两个类过于亲密，如互相调用private
重构：合并、或者改造private；或者增加委托

## 3.19 incomplete library class 不完美的类库
类库不可能满足所有未来需求，因此需要改造
改类库代码，只改一两个函数可用 introduce foreign method(162)
如果要添加一大堆额外行为，可用introduce local extension(164)

## 3.20 data class 数据类
会被其他类过分细琐的操控
对象应该承担一定责任，而不是数据的容器

## 3.21 refused bequest 被拒绝的遗赠
子类继承父类后，但是不想要所有的 父类行为或数据
传统说法：继承设计有问题，为这个子类建立兄弟类
重构：relpace inheritance with delegation(352)


---
# C4 构筑测试体系
## 4.1 自测试代码的价值
大部分时间花在哪：找bug
确保所有测试自动完成，自己坚持测试结果
一套测试就是一个强大的bug侦测器
编写测试的时机：开始编程前，明确了要测功能做什么

## 4.2 junit
## 4.3 添加更多测试

---
# C5 重构列表
## 5.1 重构的记录格式
名称
概要
动机
做法
范例

## 5.2 寻找引用点
使用IDE

## 5.3 这些重构手法有多成熟
小步前进，频繁测试

---
# C6 重新组织函数
## 6.1 Extract method(110)
一段代码从原函数提取，放进新函数
函数长度多长合适？
关键在于函数名称和本体之间的语义距离

### 做法
命名，如果没有更有意义的名字，就别动
提代码
检查提出代码内变量及作用域
检查临时变量
检查局部变量是否被改变
调用方 整理需要传的参数

## 难点
局部变量，如果调用方还要使用，则需要返回
只是新函数用，可以replace temp with query

## 6.2 Inline method(117) 
与6.1相反
### 动机
太多的间接层导致代码混乱

## 6.3 inline temp 内联临时变量
将对该变量的引用动作，替换为对它赋值的表达式自身
### 动机
妨碍了其他重构手法，如extract method

## 6.4 replace temp with query 
将表达式提炼到一个独立函数中，这个临时变量的所有引用点替换为新函数的调用，新函数就可被其他函数使用
### 动机
减少调用方长度，更清晰
### 做法
找出只被赋值一次的临时变量
将该变量声明为final，编译以确保
将变量赋值的右侧提炼到独立函数

## 6.5 introduce explaining variable 引入解释性变量
将该复杂表达式（或其中一部分）结果放进一个临时变量，以此变量名称来解释表达式用途
### 动机
表达式有可能复杂而难以阅读
extract method难以进行时

## 6.6 split temporary variable 分解临时变量
针对每次赋值，创造一个独立、对应的临时变量
### 动机
每个变量只承担一个责任，同一个临时变量承担两件不同的事，会令代码阅读者糊涂

## 6.7 remove assignments to parameters 移除对参数的赋值
以一个临时变量取代该参数的位置
### 动机
降低了代码的清晰度，混用了按值和按引用传递

## 6.8 replace method with method object
将这个函数放进一个单独对象中，如此局部变量就成了对象内字段，你可以在同一个对象内将这个大型函数分解为多个小型函数
### 动机
局部变量泛滥
无法拆解函数，不好做 extract method

## 6.9 substitute algorithm 替换算法
将函数本体替换为另一个算法
### 动机
用更清晰替代更复杂（重写）

---
# C7 在对象之间搬移特性
对象的责任放在哪
## 7.1 move method 搬移函数




































































































































