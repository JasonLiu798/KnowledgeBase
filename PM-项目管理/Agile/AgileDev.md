#敏捷软件开发-笔记
----
#计划
##发布计划
素材 优先级，商业价值

##迭代计划
一般两周
素材规模匹配开发速度

迭代期内不可改

收尾：计算本次开发速度

##任务计划

----
#测试
##TDD
正确性验证
使用不同的观察点，即使用者
迫使程序为可测试，易于调用
可运行的文档

测试促使模块隔离


---
#敏捷设计
##设计的臭味道
僵化性
	改动导致更多改动
脆弱性
	改动导致问题层出不穷
牢固性
	分离模块不易
粘滞性
	软件的、环境的
不必要的复杂性
	过早的预测需求
不必要的重复
晦涩性

----
#SRP 单一职责
一个类，应该只有一个引起它变化的原因

职责：变化的原因
职责过多导致，引起其变化的原因便会过多
一个职责的变化可能 削弱或抑制完成其他职责的能力

---
#OCP 开放-封闭原则
软件实体（类、模块、函数等）应该可以扩展，不可修改

原因：对系统进行改动 可能会导致连锁改动
怎么做：
抽象

----
#LSP Liskov替换原则
子类型必须能替代他们的基类型

错误示例：
比如在基类函数里判断对象类型，做出不同操作

只预测那些明显对于LSP违反情况，推迟其他预测

DBC design by contract 基于契约设计

退化函数

----
#DIP 依赖倒置
高层模块不应该依赖于底层模块，二者应该依赖于抽象
抽象不应该依赖于细节，细节应该依赖于抽象

---
#ISP 接口隔离
不应该强迫客户去依赖 他们不用的方法

委托 分离接口

---
#command模式
```java
public interface Command{
	void do();
}
```

undo 增加栈记录命令

##active object模式
command对象链表

---
#template method模式 strategy模式
template method
通用算法放入抽象基类

strategy模式
通用算法放入具体类

---
#facade模式 mediator模式



---
#singleton
防止创建多个对象
##优点
跨平台：可扩展为跨多个jvm
适用于任何类：构造函数私有，增加相应静态函数和变量
可透过派生类创建：可以创建一个SINGLETON子类
延迟求值：如果singleton从未使用，那绝不会创建
##缺点
销毁方法未定义：没有好的方法destroy一个singleton，即使把引用指向空，系统其它模块仍然持有singleton实例的引用
不能继承：继承类也要加相应的静态方法
效率问题：每次调用instance都要指向if
不透明性：必须要调用instance方法


#monostate
可创建多个对象，但对象内部指向static同一个内容
##优点
透明性：与常规对象无区别
可派生：共享相同的静态变量
多态性：可基于同样的静态变量表现不同行为
##缺点
不可转换性：不能通过派生把常规类转为monostat类
效率问题：有对象创建和销毁开销
内存占用：从未使用monostat，变量也要占用内存空间
平台局限：不能跨多个jvm工作

---
#null object
null object什么也不做



---
#composite



---
#observer

---
#abastract server
switch -> switchable(turnOn,turnOff)<-light(turnOn,turnOff)

#adapter模式

#bridge模式




---
#state模式
##有限状态机
嵌套switch/case实现
逻辑和实现不好分离

迁移表
速度

##state模式
分离了 动作和逻辑
动作在context类
逻辑在state派生类

##状态机编译器

---























































